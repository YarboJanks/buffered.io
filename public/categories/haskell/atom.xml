<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Haskell | OJ's rants]]></title>
  <link href="http://buffered.io/categories/haskell/atom.xml" rel="self"/>
  <link href="http://buffered.io/"/>
  <updated>2013-01-04T19:47:58+10:00</updated>
  <id>http://buffered.io/</id>
  <author>
    <name><![CDATA[OJ Reeves]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Haskell 101 at the Brisbane Functional Programming Meetup]]></title>
    <link href="http://buffered.io/posts/haskell-101-at-the-brisbane-functional-programming-meetup/"/>
    <updated>2009-08-17T17:03:00+10:00</updated>
    <id>http://buffered.io/posts/haskell-101-at-the-brisbane-functional-programming-meetup</id>
    <content type="html"><![CDATA[<p>I just thought I'd let the world know that tomorrow night, at 6pm AEST, the <a href="http://www.meetup.com/Brisbane-Functional-Programming-Group-BFG/" title="Brisbane Functional Programming Group ">Brisbane Functional Programming Group</a> is having another <a href="http://www.meetup.com/Brisbane-Functional-Programming-Group-BFG/calendar/11039537/" title="Intro to FP & Haskell 101">get-together</a>. The topics for the meeting are:</p>

<ul>
    <li>Introduction to Functional Programming - by Brad Clow</li>
    <li>Haskell 101 - by me!</li>
</ul>


<p>There are still spots available if you're keen to <a href="http://www.meetup.com/Brisbane-Functional-Programming-Group-BFG/calendar/11039537/" title="Intro to FP & Haskell 101">come along</a>. It should be fun!</p>

<p>I'm always up for some public scrutiny, so come along and bring your rotten tomatoes.</p>

<p>If you can't make it, I'll post the slides for the talk on this site, and on Meetup.com, when the event has finished so you can see what was covered. Feel free to ping me or ask questions.</p>

<p><strong>Update 19th Aug '09</strong>
The talk seemed to go quite well. I had to motor through the material quite quickly due to the late start, but on the whole I think it was well received. I haven't had any negative feedback so far ;)</p>

<p>Slides/content are now <a href="http://buffered.io/uploads/2009/08/Haskell101-20090818.zip" title="Slides and source for Haskell 101">up for grabs</a>!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Value of a Technical Community]]></title>
    <link href="http://buffered.io/posts/the-value-of-a-technical-community/"/>
    <updated>2009-07-29T07:30:00+10:00</updated>
    <id>http://buffered.io/posts/the-value-of-a-technical-community</id>
    <content type="html"><![CDATA[<p><a href="http://buffered.io/uploads/2009/07/community.jpg" rel="lightbox" title="Cricket Team Holding Hands --- Image by  Royalty-Free/Corbis"><img src="http://buffered.io/uploads/2009/07/community.jpg" alt="Cricket Team Holding Hands --- Image by  Royalty-Free/Corbis" title="Cricket Team Holding Hands --- Image by  Royalty-Free/Corbis" width="150" style="float: left; margin-right: 5px; margin-bottom: 5px;" /></a>This post was inspired by an experience I had recently in an IRC channel. To protect the innocent, I'll refrain from naming and shaming the channel and individual as those details aren't important.</p>

<p>Communities are arguably the life blood of technology. Without a good community the likelihood of the technology catching on is drastically reduced. Those communities which lack individuals that are happy to put time and effort in to help get others up to speed tend to stagnate. Any community which involves members that are abrasive, rude and downright offensive is destined to suffer long term.</p>

<!--more-->


<p>The level of suffering will vary depending on quite a few things. Those things include existing user base, the age of the technology and the number of different ways that a given <acronym title="New person">n00b</acronym> can get information about that technology.</p>

<p><a href="http://en.wikipedia.org/wiki/Internet_Relay_Chat" title="IRC">IRC</a> is a very common and popular means for members of communities to interact. It provides a real-time element that you don't get with blogs, forums and other media like <a href="http://twitter.com/" title="Twitter">Twitter</a>. It satisfies every geek's desire to get the answer and get it <strong>now</strong>. Experiencing support in real time via IRC can be extremely helpful and rewarding. It can work wonders for the popularity and image of the community and the technology itself.</p>

<p>If you're interested in seeing some active and extremely helpful communities, you should take a look at <a href="irc://chat.freenode.net/haskell" title="#haskell on freenode">#haskell</a> and <a href="irc://chat.freenode.net/mercurial" title="#mercurial on freenode">#mercurial</a>. Both of these channels are generally very active. The people that spend time in them are both helpful and friendly. Both of these channels indicate to me that there is a very healthy and vibrant community behind each of these pieces of technology.</p>

<p><a href="http://buffered.io/uploads/2009/07/anger.jpg" title="ARGH!" rel="lightbox"><img src="http://buffered.io/uploads/2009/07/anger.jpg" width="200" alt="ARGH!" title="ARGH!" style="float: right; margin-left: 5px; margin-bottom: 5px;"/></a>
Unfortunately, this kind of communication also has a downside. The real-time nature of IRC allows people to vent anger on newcomers without any means of moderation. The net result of this is that other individuals become to scared to offer their view or provide support for fear of receiving the same treatment. This goes for members with any level of skill or knowledge. There are some community channels out there containing hundreds of people, and yet there is no conversation. When questions are asked, nobody responds.</p>

<p>After my recent experience in a channel that fist this description, it's easy to see why. In less that half an hour of asking for clarification on certain points, I received a barrage of abuse which, in my view, was <strong>totally unjustified</strong>.</p>

<p>But let's say, for the sake of argument, that it was justified. That for some reason I annoyed someone in such a way that bombarding me with many 4 and 5-letter expletives was acceptable. Do <em>you</em> think that it paints a good picture of the community?</p>

<p><strong>I think <em>not</em>.</strong></p>

<p>In less than half an hour I went from excited to deflated. I lost interest in the piece of technology and lost faith in the community around it. Was my response justified or understandable?</p>

<p>I'm not sure about the answer to this :)</p>

<p>I feel that it's the job of the community to moderate other members of their community. If people get abusive then other members should step in and prevent it. In my case this wasn't possible due to the fact that the person in question was abusing me via a private chat so that the channel couldn't witness his venting. I'm guessing this wasn't the first time that he's done this to someone, nor will it be the last. I wonder how many others have suffered the same fate? If the silence of the channel is anything to go by, I'm guessing quite a few.</p>

<p>I guess what I'm trying to say here is this: don't underestimate the value and importance of your community. It's one of the most frequented faces of your technology. If it's bitter, unwelcoming and unsupportive, you will not only lose valuable newcomers who come looking for information and support, you will also lose future users due to the poor reputation. Ultimately, your tech will suffer.</p>

<p>If you're part of a community, do your bit to police it. Help those who need help. Stop those people who are abusive.</p>

<p>.. and if you don't have anything nice to say, then <em>don't say anything at all</em>!</p>

<!--adsense-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA['Point-Free style: What is it good for?']]></title>
    <link href="http://buffered.io/posts/point-free-style-what-is-it-good-for/"/>
    <updated>2009-06-27T21:49:00+10:00</updated>
    <id>http://buffered.io/posts/point-free-style-what-is-it-good-for</id>
    <content type="html"><![CDATA[<p>If you're not interested in what inspired this post, then skip this section and <a href="#MoreInteresting" title="The purpose of the post">jump</a> to the more interesting bits.</p>

<h2>A Little Bit of History</h2>

<p>Recently I've been delving into <a href="http://haskell.org/" title="Haskell">Haskell</a> quite a bit. It's part of my apparently never-ending quest to learn as much as I can about as many languages as I can (well, those that appeal to me at least :)). While I love playing around with a language, toying with ideas, writing small programs, reading books, blog posts, etc it's not really the same as having an on-call expert to help and guide you.</p>

<!--more-->


<p> While I'm aware of, and frequently visit, the <a href=http://www.haskell.org/haskellwiki/IRC_channel" title="Haskell IRC">Haskell IRC channell</a> I find that the level of understanding there is so great that my piddly <a href="http://en.wikipedia.org/wiki/Newbie" title="Newbie">noob</a> questions tend to get lost amongst the bombardment of much more advanced &amp; interesting discussions. In short, while I find it a great place to go, it's not a great place to find someone who's happy to help guide me through the maze and go over topics in quite a bit of detail while I annoy them with questions.</p>

<p>Haskell is one of those languages where having a mentor is really beneficial. So I set about finding myself one. Thankfully, I found a rather helpful chap based in the UK, <del>(he shall remain anonymous, as I don't want to violate the man's privacy)</del>, <a href="http://twitter.com/peter_marks" title="Peter Marks">Peter Marks</a>, who has been very forthcoming with information. He's humoured me and been incredibly patient so far, and I'm very grateful for his time.</p>

<p>One of the questions that I asked him was:<blockquote cite="OJ"><p>Why is it that everyone seems to strive to get their code into <a href="http://www.haskell.org/haskellwiki/Pointfree" title="Point Free">Point-Free</a> style? I can see how a lot of the implementations are more concise, but many of those lose readability.</p>

<p>What is so special about it?</p></blockquote>The discussion that followed was really insightful. That is what has inspired me to write this post.</p>

<p>Please note, any errors in this post are totally my own. They are not the fault of my mentor :)</p>

<p><span id="MoreInteresting"/></p>

<h2>The purpose of the post: Why aim for Point-Free style?</h2>

<p>So it is just me, or does anyone else out there feel that there's a bit of a "thing" going on for Point-Free style? Sometimes I share my terrible code with people and I get shunned when it's not Point-Free and it could be.</p>

<p>Anyone?</p>

<p>I hope it's not just me :) Let's start with taking a quick look at what Point-Free style actually is.</p>

<h3>So what is Point-Free style?</h3>

<p>If we take a look at the <a href=http://en.wikipedia.org/wiki/Point-free_programming" title="Wikipedia">Wikipedia</a> we can see that..<blockquote><p>Tacit [point-free] programming is a programming paradigm in which a function definition does not include information regarding its arguments, using combinators and function composition (but not ?-abstraction) instead of variables.</p></blockquote>Simple eh? :) In essence, it basically means that your function definition doesn't reference any of its arguments/variables. For a crass definition, think <em>point == argument</em> and it should make sense.</p>

<p>So we're writing functions without directly referencing its arguments. For those not familiar with Haskell or other languages that support this, let's take a look at an example:
{% codeblock lang:haskell %}
-- sum : take a list of numbers and add them all up to get a total
-- start with the base-case: an empty list
sum [] = 0
sum (x:xs) = x + sum xs
{% endcodeblock %}</p>

<p>We can see that the above function is written in such a way that the arguments passed into the function are actually referenced in the body of the code. This is how a standard imperative programmer would write this function if he/she was new to Haskell. If we instead used a <a href="http://www.haskell.org/haskellwiki/Fold" title="Fold">fold</a>, we could define it like so:
{% codeblock lang:haskell %}
sum xs = foldr (+) 0 xs
{% endcodeblock %}</p>

<p>This does exactly the same thing as the previous definition, but as you can see the grunt work is done by the fold function. Now that we have this definition, we can easily move to Point-Free style:
{% codeblock lang:haskell %}
sum = foldr (+) 0
{% endcodeblock %}</p>

<p>Here we can see that no reference is made to the arguments of the function. Since we haven't referenced any "points", we have a Point-Free implementation.</p>

<p>Awesome. Cool. Sweet. Nifty.</p>

<p>But what does it give me? Why is it better?</p>

<h3>Why use Point-Free style?</h3>

<p>This section is based totally on my own opinion and is not an official definition :) I think that Point-Free style fits in the same category as many other coding patterns and styles, and that it's usually down to the individual programmer to determine the when and the why. So take my view with a pinch of salt.</p>

<p>In short, Point-Free style let's you <em>focus on the <strong>how</strong> rather than the <strong>what</strong></em>.</p>

<p>It might be just me, but imperative programs seem to have a large focus on the data. The code which operates on the data is lost within a plethora of code that isn't necessarily specific to what the program needs to do. I've found that functional programming tends to be very different, at least in Haskell. Haskell lets me focus on what it is I need to do, and I feel that Point-Free is another step in the same direction. Is this good? I think so :) But I'll let you decide.</p>

<p>As well as the focus on the <strong>what</strong> I've found that aiming for a Point-Free solution can aid in helping you understand your problem better. This claim sounds like fluff, so let's go through an example and hopefully you'll see what I mean.</p>

<h3>Where Point-Free helped me get a better understanding</h3>

<p>Haskell developers use the <a href="http://www.haskell.org/haskellwiki/Function_composition" title="Function composition">composition operator</a> <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html#." title="(.) implementation in Prelude">(.)</a> a lot. It actually aids in creating Point-Free style. I love the irony here. We add points (.) to remove points (arguments).</p>

<p>Anyway, the composition operator's definition, according to <a href="http://www.haskell.org/onlinereport/standard-prelude.html" title="Prelude">Prelude</a> is:
{% codeblock lang:haskell %}
(.)       :: (b -> c) -> (a -> b) -> a -> c
(.) f g x = f (g x)
{% endcodeblock %}</p>

<p>This operator takes two functions and produces a function which is composed of the two. This function takes the output of one function and sends it through as the input to another function, returning the result of that call.</p>

<p>This is really handy. We can do some interesting things like:</p>

<pre><code>ghci&gt; let doubleAndAdd5 = (+5) . (*2)
ghci&gt; doubleAndAdd5 20
45
ghci&gt; :m +Data.List
ghci&gt; let sumColumns = map sum . transpose
ghci&gt; sumColumns [[1,2,3],[4,5,6],[7,8,9]]
[12,15,18]
</code></pre>

<p>Very handy indeed. While handy, it doesn't necessarily allow us to do everything we might want to do. One example is handling cases where we want to compose a function where the right-hand function takes two arguments instead of one.</p>

<p>So if we wanted to create a function that would take two values, add them together and double the result, all while using Point-Free style, we'd like to do something like this:</p>

<pre><code>ghci&gt; let addAndDouble = (*2) . (+)

&lt;interactive&gt;:1:20:
    No instance for (Num (a -&gt; a))
      arising from a use of `*' at &lt;interactive&gt;:1:20-21
    Possible fix: add an instance declaration for (Num (a -&gt; a))
    In the first argument of `(.)', namely `(* 2)'
    In the expression: (* 2) . (+)
    In the definition of `addAndDouble': addAndDouble = (* 2) . (+)
ghci&gt;
</code></pre>

<p>As you can see, ghci doesn't like it. And rightly so! This is because the composition operator's signature is:
{% codeblock lang:haskell %}
(.) :: (b -> c) -> (a -> b) -> a -> c
{% endcodeblock %}</p>

<p>That is:</p>

<ol><li>It takes an argument which is a function which takes a value of type <em>b</em> which returns a value of type <em>c</em></li><li>It takes a function which takes a value of type <em>a</em> which returns returns a value of type <em>b</em></li><li>It returns a new function which takes a value of type <em>a</em> and returns a value of type <em>c</em></li></ol>


<p>This doesn't work in our case, as we want our right-hand function to take two arguments. That is, we want a type signature that looks like this:
{% codeblock lang:haskell %}
foo :: (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
{% endcodeblock %}</p>

<p>So everywhere we had <em>(a -> b)</em>, what we really want is <em>(a -> a1 -> b)</em>. Given that we don't have an operator that does that for us, let's define one. We'll start with the definition of the (.) operator and work towards a function that does what we need.</p>

<p>{% codeblock lang:haskell %}
-- here is the composition operator again
(.) f g x = f (g x)
-- here's our new operator's definition
(.<sup>)</sup> f g x y = f (g x y)
{% endcodeblock %}</p>

<p>Simple! Let's see what ghci says about it:</p>

<pre><code>ghci&gt; let (.^) f g x y = f (g x y)
ghci&gt; :t (.^)
a :: (t2 -&gt; t3) -&gt; (t -&gt; t1 -&gt; t2) -&gt; t -&gt; t1 -&gt; t3
</code></pre>

<p>Looks good! This is exactly what we need. Now that we have a working function, let's aim to write this in Point-Free style. We do this by breaking down the function slowly and eliminating arguments by moving them to the far right hand side of the function definition.</p>

<p>The first argument to get rid of is 'y', as this is the last argument passed in:
{% codeblock lang:haskell %}
-- start by moving y to the right
(.<sup>)</sup> f g x y = f (g x y)
-- becomes
(.<sup>)</sup> f g x y = f . (g x) $ y
{% endcodeblock %}</p>

<p>These are functionally equivalent, and now that 'y' is out on it's own, we can drop it from our function definition:</p>

<pre><code>ghci&gt; let (.^) f g x = f . (g x)
ghci&gt; :t (.^)
(.^) :: (b -&gt; c) -&gt; (t -&gt; a -&gt; b) -&gt; t -&gt; a -&gt; c
ghci&gt;
</code></pre>

<p>Excellent, we're a step closer. Now we need to do the same with 'x'. This takes a little more fiddling:
{% codeblock lang:haskell %}
-- we need to take the original definition
(.<sup>)</sup> f g x = f . (g x)
-- and change it so that it uses prefix notation instead of infix
(.<sup>)</sup> f g x = (.) f (g x)
-- which is the same as
(.<sup>)</sup> f g x = ((.) f) (g x)
-- what we're doing is calling g with x and applying the result to f
-- and hence we can compose the composition of f with the call to g
-- giving us the following
(.<sup>)</sup> f g x = ((.) f) . g $ x
-- finally leaving us with
(.<sup>)</sup> f g = ((.) f) . g
{% endcodeblock %}</p>

<p>Phew :) I hope you can see the progression. We've managed to move x out of the picture, so now we're down to a fairly crazy looking definition. Let's see what ghci has to say:</p>

<pre><code>ghci&gt; let (.^) f g = ((.) f) . g
ghci&gt; :t (.^)
(.^) :: (b -&gt; c) -&gt; (a1 -&gt; a -&gt; b) -&gt; a1 -&gt; a -&gt; c
</code></pre>

<p>So we've got rid of two variables, but there are still two more to go! Remember, 'f' and 'g' are still variables, they just carry functions. So let's get rid of 'g':
{% codeblock lang:haskell %}
-- start with what we had before
(.<sup>)</sup> f g = ((.) f) . g
-- change to prefix notation again
(.<sup>)</sup> f g = (.) ((.) f) g
-- and drop g
(.<sup>)</sup> f = (.) ((.) f)
{% endcodeblock %}</p>

<p>This is looking rather crazy :) Again, let's make sure we haven't done anything stupid:</p>

<pre><code>ghci&gt; let (.^) f = (.) ((.) f)
ghci&gt; :t (.^)
(.^) :: (b -&gt; c) -&gt; (a1 -&gt; a -&gt; b) -&gt; a1 -&gt; a -&gt; c
</code></pre>

<p>Excellent. We've still got what we need. One more point needs to be dropped, so let's get rid of 'f':
{% codeblock lang:haskell %}
-- start with what we had before
(.<sup>)</sup> f = (.) ((.) f)
-- which means that we're composing a composition with a
-- function composed of f and something else
(.<sup>)</sup> f = (.) . (.) $ f
-- and we finally drop f
(.<sup>)</sup> = (.) . (.)
{% endcodeblock %}</p>

<p>Isn't that just crazy! Let's again check ghci:</p>

<pre><code>ghci&gt; let (.^) = (.) . (.)
ghci&gt; :t (.^)
(.^) :: (b -&gt; c) -&gt; (a1 -&gt; a -&gt; b) -&gt; a1 -&gt; a -&gt; c
</code></pre>

<p>So there we have it, our operator completely in Point-Free style.</p>

<p>This is where the penny dropped for me. The whole exercise of moving through to Point-Free made me really understand what it was I was doing in the first place. The final definition makes it very clear. We're composing two separate compositions.
Let's see if our function behaves itself using the example we listed above.</p>

<pre><code>ghci&gt; let addAndDouble = (*2) .^ (+)
ghci&gt; :t addAndDouble
addAndDouble :: Integer -&gt; Integer -&gt; Integer
ghci&gt; addAndDouble 10 15
50
ghci&gt; addAndDouble 21 3
48
</code></pre>

<p>It does exactly what we need it too.</p>

<h2>Conclusion</h2>

<p>To sum up, Point-Free helps you tidy your code into more concise implementations which tend to aid you in understanding what it is you are trying to do. I feel it really helps you focus on what you're doing as opposed to what you're doing it to. It's down to you to determine whether you feel this is a good thing or not!</p>

<p>It is ultimately down to the developer to dictate when it should be used. There are definitely cases where the resulting function might not actually help in making things clearer. But on the whole, Point-Free style seems to help me understand what it is I'm doing (or, arguably, not doing).</p>

<p>Of course, you could just get sick and tired of trying to come up with variable names, in which case Point-Free is the bomb :)</p>

<p>Feedback of any kind is always welcome. Cheers!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Data Crunching in Haskell]]></title>
    <link href="http://buffered.io/posts/data-crunching-in-haskell/"/>
    <updated>2009-06-25T00:00:00+10:00</updated>
    <id>http://buffered.io/posts/data-crunching-in-haskell</id>
    <content type="html"><![CDATA[<p>A few days ago I was having a chat to a <a href="http://shiftperception.com/blog" title="Shifty">friend of mine</a> about a little data parsing problem. He had the need to parse a multi-dimensional array to pull out some values. That array was guaranteed to be square, but not necessarily in contiguous memory. He needed to parse each "column" of the array, calculate a total, and then determine the biggest and smallest of those totals.</p>

<p>A sample of the data might look something like this:</p>

<pre><code>data = ({150,200,45,57,95,2,45,32,15,10,5,2,2,4},
         12,20,45,37,10,5,2,2,10,95,2,45,32,7},
         32,15,10,5,2,23,24,15,20,45,57,95,0,45})
</code></pre>

<p>So the first step would be to add 150, 12 and 32 and store the value. Then 200, 20 and 15, and store the value. Do this for all of the columns, then get a maximum and a minimum.</p>

<!--more-->


<p>This little algorithm was going to be part of his project, and hence needed to be implemented in <a href="http://www.adobe.com/devnet/actionscript/articles/actionscript3_overview.html" title="ActionScript 3.0">AS3</a>. So I picked his brains about the AS3 syntax, because I have absolutely no clue given that I've never worked with any version of ActionScript in the past.</p>

<p>Together, we came up with the following solution:</p>

<pre><code>var columnTotal:Number;
var biggest:Number;
var smallest:Number;
biggest = smallest = sum(vData, 0);

for(var i = 1; i &lt; _scope.period_mcs.length; ++i)
{
  columnTotal = sum(vData, i);
  biggest = Math.max(biggest, columnTotal);
  smallest = Math.min(smallest, columnTotal);
}

// helper function 
function sum(var data:Array, var index:Integer):Number
{
  var total:Number = 0;
  for(int i = 0; i &lt; data.length; ++i)
  {
    total += data[i][index];
  }
  return total;
}
</code></pre>

<p>Does it work? Yes, it sure does. Is it optimal? Yes, and no :) I was lazy and used the Math.max and Math.min functions instead of doing the obvious...</p>

<pre><code>if(biggest &lt; columnTotal) biggest = columnTotal;
</code></pre>

<p>So if we did that, to reduce the need for function calls and unnecessary assignments, we end up with this:</p>

<pre><code>var columnTotal:Number;
var biggest:Number;
var smallest:Number;
biggest = smallest = sum(vData, 0);

for(var i = 1; i &lt; _scope.period_mcs.length; ++i)
{
  columnTotal = sum(vData, i);
  if(biggest &lt; columnTotal)
  {
    biggest = columnTotal;
  }
  else if(smallest &gt; columnTotal)
  {
    smallest = columnTotal;
  }
}

// helper function 
function sum(var data:Array, var index:Integer):Number
{
  var total:Number = 0;
  for(int i = 0; i &lt; data.length; ++i)
  {
    total += data[i][index];
  }
  return total;
}
</code></pre>

<p>I can't see many ways to improve on this without going overboard with optimisation. Any AS3 guru's are more than welcome to prove me wrong!</p>

<p>So after thinking about this in an imperative language, I couldn't help but have a look at what the functional version might look like. Of course, my current chosen Functional toy is <a href="http://haskell.org/" title="Haskell">Haskell</a> and so I fired up <a href="http://vim.org/" title="VIM">VIM</a> and <a href="http://www.haskell.org/ghc/" title="GHC">GHCI</a> and had a bit of a play.</p>

<p>First, I put the data into Haskell's list format:</p>

<p>{% codeblock lang:haskell %}
vals = [[150,200,45,57,95,2,45,32,15,10,5,2,2,4],</p>

<pre><code>    [12,20,45,37,10,5,2,2,10,95,2,45,32,7],
    [32,15,10,5,2,23,24,15,20,45,57,95,0,45]]
</code></pre>

<p>{% endcodeblock %}</p>

<p>That was easy enough. The next step was to break the problem down so that I could use some of the built in functions of Haskell's <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html" title="Prelude">Prelude</a> libraries. My thought processes were:</p>

<ol>
<li>Summing the column of the array could be done using <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:sum" title="sum">sum</a>, but I'd need to change the list so that rows become columns, and vice-versa.</li>
<li>To switch rows and columns, I could use the <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v:transpose" title="Data.List.transpose">transpose</a> function.</li>
<li>Then all I'd need to do is use <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:maximum" title="maximum">maximum</a> and <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:minimum" title="minimum">minimum</a> to get the right values out.</li>
</ol>


<p>Being a bit of a primitive Haskeller, my first pass was something like this:
{% codeblock lang:haskell %}
extremes n = (b, s)
  where</p>

<pre><code>l = map sum $ transpose n
b = maximum l
s = minimum l
</code></pre>

<p>{% endcodeblock %}</p>

<p>The function <em>extremes</em> is the function which takes the data (list of lists) and spits out a tuple of <em>(max, min)</em>.</p>

<p>Before the end of the conversation with my designer colleague in arms, I pinged him my version of the solution in Haskell and needless to say he was a little surprised as how concise it was. I was sure to point out that there is no doubt a better way of representing this solution with regards to speed and conciseness.</p>

<p>The first thing that I thought could be improved would be using a custom <a href="http://www.haskell.org/haskellwiki/Fold" title="Fold">fold</a> to get the max and min while parsing the transposed list. This would allow us to calculate the values in a single pass and hence be a little better with regards to performance. That would obviously sacrifice a little bit of the conciseness we're looking for.</p>

<p>When the conversation ended, I jumped onto IRC and spoke to some more seasoned Haskellers. The first suggested improvement that popped out of that chat was to use <a href="http://www.haskell.org/arrows/" title="Arrows">arrows</a> to remove the need for the where clause. That solution looks like this:
{% codeblock lang:haskell %}
extremes = (maximum &amp;&amp;&amp; minimum) . map sum . transpose
{% endcodeblock %}</p>

<p>Nifty :) Of all the other options, this proved to be the most readable and concise, though not the best performing.</p>

<p>The next most notable solution included the fold which calculated the min and max in a single parse, not a double parse:
{% codeblock lang:haskell %}
extremes = foldl1 ((a, b) -> max a *** min b) . join zip . map sum . transpose
{% endcodeblock %}</p>

<p>Folds really are fantastic aren't they. Again we're using arrows here to do a bit of heavy lifting and that keeps things looking a little nicer.</p>

<p>So after this little session, my designer friend was aware of how easy it can be to crunch certain types of data using a functional language, like Haskell. It made me think again about how it'd be nice to just be able to plug in whichever language we wanted whenever we felt it would do the job better than whatever the current tool is.</p>

<p>So how would you improve it? :)</p>

<!--adsense-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler #10]]></title>
    <link href="http://buffered.io/posts/project-euler-10/"/>
    <updated>2008-07-30T21:27:00+10:00</updated>
    <id>http://buffered.io/posts/project-euler-10</id>
    <content type="html"><![CDATA[<p><strong>WARNING!</strong> This post contains a spoiler for Problem #10 listed at <a href="http://projecteuler.net/" title="Project Euler">Project Euler</a>. Do not read the rest of this post if you're planning to attempt to solve the problem yourself.</p>

<!--more-->


<p><a title="Project Euler #10" href="http://projecteuler.net/index.php?section=problems&amp;id=10">Problem #10</a> takes us back into the realm of the relatively boring - prime numbers (again). The question is as follows:<blockquote><p>The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.</p>

<p>Find the sum of all the primes below two million.</p></blockquote>
Exciting stuff! Since we've already got ourselves a relatively nifty prime number generator from a <a title="Project Euler #7" href="http://buffered.io/posts/project-euler-7/">previous post</a>, we can simply reuse this, along with the sum function that comes in <a title="Prelude" href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Prelude</a>, to generate the answer.</p>

<p>Here is what the code looks like:
{% codeblock lang:haskell %}
merge :: (Ord a) => [a] -> [a] -> [a]
merge xs@(x:xt) ys@(y:yt) =
  case compare x y of</p>

<pre><code>LT -&gt; x : (merge xt ys)
EQ -&gt; x : (merge xt yt)
GT -&gt; y : (merge xs yt)
</code></pre>

<p>diff :: (Ord a) => [a] -> [a] -> [a]
diff xs@(x:xt) ys@(y:yt) =
  case compare x y of</p>

<pre><code>LT -&gt; x : (diff xt ys)
EQ -&gt; diff xt yt
GT -&gt; diff xs yt
</code></pre>

<p>primes, nonprimes :: [Integer]
primes    = [2, 3, 5] ++ (diff [7, 9 ..] nonprimes)
nonprimes = foldr1 f $ map g $ tail primes
  where</p>

<pre><code>f (x:xt) ys = x : (merge xt ys)
g p         = [ n * p | n &lt;- [p, p + 2 ..]]
</code></pre>

<p>main :: IO ()
main = print $ sum (takeWhile (&lt;2000000) primes)
{% endcodeblock %}</p>

<p>I don't really have much else to say about this. I won't bother with the performance information because it's not really doing anything too exciting that hasn't already been discussed.</p>

<p>Cheers!</p>
]]></content>
  </entry>
  
</feed>
