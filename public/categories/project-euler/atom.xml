<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Project Euler | OJ's rants]]></title>
  <link href="http://buffered.io/categories/project-euler/atom.xml" rel="self"/>
  <link href="http://buffered.io/"/>
  <updated>2013-01-04T19:47:58+10:00</updated>
  <id>http://buffered.io/</id>
  <author>
    <name><![CDATA[OJ Reeves]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Project Euler #10]]></title>
    <link href="http://buffered.io/posts/project-euler-10/"/>
    <updated>2008-07-30T21:27:00+10:00</updated>
    <id>http://buffered.io/posts/project-euler-10</id>
    <content type="html"><![CDATA[<p><strong>WARNING!</strong> This post contains a spoiler for Problem #10 listed at <a href="http://projecteuler.net/" title="Project Euler">Project Euler</a>. Do not read the rest of this post if you're planning to attempt to solve the problem yourself.</p>

<!--more-->


<p><a title="Project Euler #10" href="http://projecteuler.net/index.php?section=problems&amp;id=10">Problem #10</a> takes us back into the realm of the relatively boring - prime numbers (again). The question is as follows:<blockquote><p>The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.</p>

<p>Find the sum of all the primes below two million.</p></blockquote>
Exciting stuff! Since we've already got ourselves a relatively nifty prime number generator from a <a title="Project Euler #7" href="http://buffered.io/posts/project-euler-7/">previous post</a>, we can simply reuse this, along with the sum function that comes in <a title="Prelude" href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Prelude</a>, to generate the answer.</p>

<p>Here is what the code looks like:
{% codeblock lang:haskell %}
merge :: (Ord a) => [a] -> [a] -> [a]
merge xs@(x:xt) ys@(y:yt) =
  case compare x y of</p>

<pre><code>LT -&gt; x : (merge xt ys)
EQ -&gt; x : (merge xt yt)
GT -&gt; y : (merge xs yt)
</code></pre>

<p>diff :: (Ord a) => [a] -> [a] -> [a]
diff xs@(x:xt) ys@(y:yt) =
  case compare x y of</p>

<pre><code>LT -&gt; x : (diff xt ys)
EQ -&gt; diff xt yt
GT -&gt; diff xs yt
</code></pre>

<p>primes, nonprimes :: [Integer]
primes    = [2, 3, 5] ++ (diff [7, 9 ..] nonprimes)
nonprimes = foldr1 f $ map g $ tail primes
  where</p>

<pre><code>f (x:xt) ys = x : (merge xt ys)
g p         = [ n * p | n &lt;- [p, p + 2 ..]]
</code></pre>

<p>main :: IO ()
main = print $ sum (takeWhile (&lt;2000000) primes)
{% endcodeblock %}</p>

<p>I don't really have much else to say about this. I won't bother with the performance information because it's not really doing anything too exciting that hasn't already been discussed.</p>

<p>Cheers!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler #9]]></title>
    <link href="http://buffered.io/posts/project-euler-9/"/>
    <updated>2008-07-25T22:08:00+10:00</updated>
    <id>http://buffered.io/posts/project-euler-9</id>
    <content type="html"><![CDATA[<p><strong>WARNING!</strong> This post contains a spoiler for Problem #9 listed at <a href="http://projecteuler.net/" title="Project Euler">Project Euler</a>. Do not read the rest of this post if you're planning to attempt to solve the problem yourself.</p>

<!--more-->


<p><a href="http://projecteuler.net/index.php?section=problems&id=9">Problem #9</a> takes a turn back into the math theory and forces you to think about Pythagorean triplets. It goes as follows:<blockquote><p>
A Pythagorean triplet is a set of three natural numbers, a  b  c, for which,
&nbsp;&nbsp;&nbsp;&nbsp;a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup></p>

<p>For example, 3<sup>2</sup> + 4<sup>2</sup> = 9 + 16 = 25 = 5<sup>2</sup>.</p>

<p>There exists exactly one Pythagorean triplet for which a + b + c = 1000.
Find the product abc.
</p></blockquote>
The first solution to this problem that I came up with was just atrocious :) It was long, bloated and extremely messy. But it worked. If you really want to see it then ask me nicely and I'll post it.</p>

<p>For now I'm going to show you my second attempt, which is a little nicer on the eyes.
{% codeblock lang:haskell %}
main :: IO ()
main = print $ head [ a * b * c</p>

<pre><code>                | b &lt;- [1..400],
                  a &lt;- [b..400],
                  let c = 1000 - a - b,
                  c^2 == a^2 + b^2 ]
</code></pre>

<p>{% endcodeblock %}</p>

<p>It's a mini brute-forcer which uses two variables to count up to 400. I chose 400 as the end number because it seemed like a stupid idea to go as far as 500 when brute forcing since the first of the numbers that fit the criteria wouldn't be anywhere near that high. For each combination of numbers I pick what's left over and check to see if it fits the rules of a Pythagorean triplet. In this case there is only one that does (as per the question).</p>

<p>We can see below that the solution isn't particularly fantastic as far as performance goes. It's not terrible, but approaching .2 seconds for a problem like this is starting to get on the sluggish side.</p>

<pre><code>  Fri Jul 25 21:28 2008 Time and Allocation Profiling Report  (Final)

     main +RTS -p -RTS

  total time  =        0.18 secs   (9 ticks @ 20 ms)
  total alloc =  29,337,532 bytes  (excludes profiling overheads)

COST CENTRE   MODULE  %time %alloc

CAF           Main    100.0  100.0


                                           individual    inherited
COST CENTRE   MODULE      no.    entries  %time %alloc   %time %alloc

MAIN          MAIN          1           0   0.0    0.0   100.0  100.0
 CAF          Main        152          16 100.0  100.0   100.0  100.0
 CAF          GHC.Handle   88           4   0.0    0.0     0.0    0.0
</code></pre>

<p>Another way of brute-force solving this is to abuse a bit of math. We know that each Pythagorean triplet is representative of the sides of a triangle. Given that the sides of a triangle scale evenly when the entire triangle is scaled, we can assume that if we were able to find a triplet whose sum is a factor of 1000, then we could use this factor to generate a, b and c. It turns out that the 5th Pythagorean triplet (8, 15, 17) adds up to 40, and since 40 * 25 == 1000, we can simply multiple each of the values by 25 to get (200, 375, 425).</p>

<p>While this is interesting, brute-force methods aren't never really the nicest way of solving a given problem. In the case of Project Euler it's rare to find a problem that doesn't have some form of trickery that can be abused to get the answer in a much more efficient manner. The theory that should be used is that each Pythagorean triplet can be <a href="http://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple">written in the following form</a>:</p>

<pre><code>k [ m^2 - n^2, 2mn, m^2 + n^2 ]
</code></pre>

<p>This info can be abused to come up with some code to generate the answer rather quickly. At this point, I become tired of the problem and decided not to implement a version that uses this theory. If you decide to write one, please ping me!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler #8]]></title>
    <link href="http://buffered.io/posts/project-euler-8/"/>
    <updated>2008-07-24T20:55:00+10:00</updated>
    <id>http://buffered.io/posts/project-euler-8</id>
    <content type="html"><![CDATA[<p><strong>WARNING!</strong> This post contains a spoiler for Problem #8 listed at <a href="http://projecteuler.net/" title="Project Euler">Project Euler</a>. Do not read the rest of this post if you're planning to attempt to solve the problem yourself.</p>

<!--more-->


<p><a href="http://projecteuler.net/index.php?section=problems&id=8">Problem #8</a> was thankfully a great deal more interesting than <a href="http://buffered.io/posts/project-euler-7/" title="Project Euler #7">the last problem</a>. It goes as follows..</p>

<blockquote><p>Find the greatest product of five consecutive digits in the 1000-digit number.


       73167176531330624919225119674426574742355349194934
       96983520312774506326239578318016984801869478851843
       85861560789112949495459501737958331952853208805511
       12540698747158523863050715693290963295227443043557
       66896648950445244523161731856403098711121722383113
       62229893423380308135336276614282806444486645238749
       30358907296290491560440772390713810515859307960866
       70172427121883998797908792274921901699720888093776
       65727333001053367881220235421809751254540594752243
       52584907711670556013604839586446706324415722155397
       53697817977846174064955149290862569321978468622482
       83972241375657056057490261407972968652414535100474
       82166370484403199890008895243450658541227588666881
       16427171479924442928230863465674813919123162824586
       17866458359124566529476545682848912883142607690042
       24219022671055626321111109370544217506941658960408
       07198403850962455444362981230987879927244284909188
       84580156166097919133875499200524063689912560717606
       05886116467109405077541002256983155200055935729725
       71636269561882670428252483600823257530420752963450

</p></blockquote>


<p>I'm keeping with my <a href="http://haskell.org/" title="Haskell">Haskell</a> theme and abusing some of the nice feature of Functional Programming to nail this one.</p>

<p>Here's my solution:
{% codeblock lang:haskell %}
-- ord is required to convert chars to ints
import Data.Char (ord)</p>

<p>-- a string representation of the large number
number :: String
number =</p>

<pre><code> "73167176531330624919225119674426574742355349194934"
</code></pre>

<p>  ++ "96983520312774506326239578318016984801869478851843"
  ++ "85861560789112949495459501737958331952853208805511"
  ++ "12540698747158523863050715693290963295227443043557"
  ++ "66896648950445244523161731856403098711121722383113"
  ++ "62229893423380308135336276614282806444486645238749"
  ++ "30358907296290491560440772390713810515859307960866"
  ++ "70172427121883998797908792274921901699720888093776"
  ++ "65727333001053367881220235421809751254540594752243"
  ++ "52584907711670556013604839586446706324415722155397"
  ++ "53697817977846174064955149290862569321978468622482"
  ++ "83972241375657056057490261407972968652414535100474"
  ++ "82166370484403199890008895243450658541227588666881"
  ++ "16427171479924442928230863465674813919123162824586"
  ++ "17866458359124566529476545682848912883142607690042"
  ++ "24219022671055626321111109370544217506941658960408"
  ++ "07198403850962455444362981230987879927244284909188"
  ++ "84580156166097919133875499200524063689912560717606"
  ++ "05886116467109405077541002256983155200055935729725"
  ++ "71636269561882670428252483600823257530420752963450"</p>

<p>-- converts the number to a list of Int values
numberList :: [Int]
numberList = map (\n -> ord n - ord '0') number</p>

<p>-- breaks up the number list into chunks of 5 digits
chunks :: [[Int]]
chunks = c' numberList 5 995
  where</p>

<pre><code>c' _ _ 0 = []
c' l n c = (take n l) : c' (tail l) n (c - 1)
</code></pre>

<p>-- main function iterates over the list of chunks,
-- calculates the product of each of the chunks and
-- then determines the biggest result
main :: IO ()
main = print $ foldr1 max (map product chunks)
{% endcodeblock %}</p>

<p>The comments are pretty descriptive of what goes on. It turns out that the solution isn't that shabby in the performance stakes either:</p>

<pre><code>Thu Jul 24 20:46 2008 Time and Allocation Profiling Report  (Final)

     main +RTS -p -RTS

  total time  =        0.00 secs   (0 ticks @ 20 ms)
  total alloc =     571,224 bytes  (excludes profiling overheads)

COST CENTRE   MODULE  %time %alloc

CAF           Main      0.0   99.8

                                           individual    inherited
COST CENTRE   MODULE        no.  entries  %time %alloc   %time %alloc

MAIN          MAIN            1         0   0.0    0.0     0.0  100.0
 CAF          Main          152        15   0.0   99.8     0.0   99.8
 CAF          GHC.Handle     88         4   0.0    0.2     0.0    0.2
</code></pre>

<p>I still love how concise and easy the solutions to problems like this are in Haskell.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler #7]]></title>
    <link href="http://buffered.io/posts/project-euler-7/"/>
    <updated>2008-06-15T04:53:00+10:00</updated>
    <id>http://buffered.io/posts/project-euler-7</id>
    <content type="html"><![CDATA[<p><strong>WARNING!</strong> This post contains a spoiler for Problem #7 listed at <a href="http://projecteuler.net/" title="Project Euler">Project Euler</a>. Do not read the rest of this post if you're planning to attempt to solve the problem yourself.</p>

<!--more-->


<p><a href="http://projecteuler.net/index.php?section=problems&id=7">Problem #7</a> was as boring as batshit (to be quite frank). The only reason I'm posting about it is to keep <a href="http://berkshirehunt.com/" title="Berkshire Hunt">The Head</a> happy ;)</p>

<p>The reason I thought it was boring was because it was just the age-old problem of "how fast can you generate primes":<blockquote><p>
By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.</p>

<p>What is the 10001st prime number?</p></blockquote>
A simple search of the web reveals a million different ways of solving this problem -- mostly written by people smarter than me :)</p>

<p>So did I cheat? No I didn't. I wrote the standard <a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" title="Sieve of Eratosthenes">Sieve of Eratosthenes</a> implementation in Haskell and got the answer in a respectable amount of time. Exciting stuff :|</p>

<p>I browsed around the web a little bit after solving the problem because I was interested to see how others might have solved it using Haskell. Yes, I am aware that there is a <a href="" title="">whole page dedicated to it</a> but that wasn't enough.</p>

<p>After a bit of a search, I stumbled across this little doozy. If you can make heads or tails of it you're a better man than I ;) It's quite a mind job to get your head around how this code works. This is an exercise I leave to the reader.
{% codeblock lang:haskell %}
merge :: (Ord a) => [a] -> [a] -> [a]
merge xs@(x:xt) ys@(y:yt) =
  case compare x y of</p>

<pre><code>LT -&gt; x : (merge xt ys)
EQ -&gt; x : (merge xt yt)
GT -&gt; y : (merge xs yt)
</code></pre>

<p>diff :: (Ord a) => [a] -> [a] -> [a]
diff xs@(x:xt) ys@(y:yt) =
  case compare x y of</p>

<pre><code>LT -&gt; x : (diff xt ys)
EQ -&gt; diff xt yt
GT -&gt; diff xs yt
</code></pre>

<p>primes, nonprimes :: [Integer]
primes    = [2, 3, 5] ++ (diff [7, 9 ..] nonprimes)
nonprimes = foldr1 f $ map g $ tail primes
  where</p>

<pre><code>f (x:xt) ys = x : (merge xt ys)
g p         = [ n * p | n &lt;- [p, p + 2 ..]]
</code></pre>

<p>main :: IO ()
main = print $ primes !! 10000
{% endcodeblock %}</p>

<p>Enjoy :)</p>

<p>PS. Jon - are ya happy now? :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler #6]]></title>
    <link href="http://buffered.io/posts/project-euler-6/"/>
    <updated>2008-03-28T21:06:00+10:00</updated>
    <id>http://buffered.io/posts/project-euler-6</id>
    <content type="html"><![CDATA[<p><strong>WARNING!</strong> This post contains a spoiler for Problem #6 listed at <a href="http://projecteuler.net/" title="Project Euler">Project Euler</a>. Do not read the rest of this post if you're planning to attempt to solve the problem yourself.</p>

<!--more-->


<p><a href="http://projecteuler.net/index.php?section=problems&id=6">Problem #6</a> was a <em>little</em> bit of a disappointment, but I think that's because the solution was so extremely simple using Haskell. Again, we'll check out the question first:<blockquote><p>The sum of the squares of the first ten natural numbers is,
1<sup>2</sup> + 2<sup>2</sup> + ... + 10<sup>2</sup> = 385</p>

<p>The square of the sum of the first ten natural numbers is,
(1 + 2 + ... + 10)<sup>2</sup> = 55<sup>2</sup> = 3025</p>

<p>Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 - 385 = 2640.</p>

<p>Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.</p></blockquote>Now there are two main ways of doing this. The first requires knowledge of the properties of each of the two "bits" that we need to determine. If you Google enough, you'll find information which leads you to two different formulae; one which gives you the sum of the squares, the other the square of the sums. These will tell you how to solve each in O(1) time. Combine the two and you'll have a magic formula for solving the problem in a single step.</p>

<p>As for me, after doing the research I found no thrill in writing a function which took an integer and returned an integer that's the result of a basic equation. So instead, I wrote the following:
{% codeblock lang:haskell %}
main :: IO ()
main = print $ (sum [1..100]) ^ 2 - sum [ x<sup>2</sup> | x &lt;- [1..100] ]
{% endcodeblock %}</p>

<p>Nice and concise. Sure it takes longer as the numbers increase, but what the hell! If I need to do it in the real world I'll use the method that I haven't posted :).</p>

<p>I'd ask for thoughts, but for this problem there really aren't too many that can be had! On to the next problem.</p>
]]></content>
  </entry>
  
</feed>
