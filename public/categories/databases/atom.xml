<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Databases | OJ's rants]]></title>
  <link href="http://buffered.io/categories/databases/atom.xml" rel="self"/>
  <link href="http://buffered.io/"/>
  <updated>2012-02-15T20:11:32+10:00</updated>
  <id>http://buffered.io/</id>
  <author>
    <name><![CDATA[OJ Reeves]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Webmachine, ErlyDTL and Riak - Part 3]]></title>
    <link href="http://buffered.io/posts/webmachine-erlydtl-and-riak-part-3/"/>
    <updated>2010-10-13T06:31:00+10:00</updated>
    <id>http://buffered.io/posts/webmachine-erlydtl-and-riak-part-3</id>
    <content type="html"><![CDATA[<p><img src="http://buffered.io/uploads/2010/09/riak-logo.png" alt="Riak Logo" style="float:left;padding-right:5px;padding-bottom:5px;"/>For those of you who are new to the series, you may want to check out <a href="/posts/webmachine-erlydtl-and-riak-part-1/" title="Wembachine, ErlyDTL and Riak - Part 1">Part 1</a> and <a href="/posts/webmachine-erlydtl-and-riak-part-2/" title="Wembachine, ErlyDTL and Riak - Part 2">Part 2</a> before reading this post. It will help give you some context as well as introduce you to some of the jargon and technology that I'm using. If you've already read then, or don't want to, then please read on!</p>

<p>This post builds on the previous two, but not without a few little modifications. If you're interested in following along step by step with your own version of the code running, then get yourself a copy of <a href="https://bitbucket.org/OJ/csd/changeset/df62880d12a8" title="Source code for Part 2">this changeset</a> before doing so.</p>

<p>In this post we're going to cover:</p>

<ol>
<li>A slight refactor of code structure to support the "standard" approach to building applications in Erlang using OTP.</li>
<li>Building a small set of modules to talk to <a href="http://www.basho.com/developers.html#Riak" title="Riak">Riak</a>.</li>
<li>Creation of some <a href="http://json.org/" title="JavaScript Object Notation">JSON</a> helper functions for reading and writing data.</li>
<li>Calling all the way from the <a href="http://www.basho.com/developers.html#Webmachine" title="Webmachine">Webmachine</a> front-end to Riak to extract data and display it in a browser using <a href="http://github.com/evanmiller/erlydtl" title="ErlyDTL">ErlyDTL</a> templates.</li>
</ol>


<p>There are quite a few code snippets in this post as well as output from script executions and <code>bash</code> sessions. To avoid confusion, all file listings reference the path to the file that is being modified relative to the root of the project folder.</p>

<p>Be warned, this is a <em>long</em> post :) Get yourself a <em>shmoke und a pancake</em>, a glass of your favourite beverage and put some relaxing music on (instrumental is best).</p>

<p>Are you ready? OK, here we go ...</p>

<!--more-->


<h2>A Slight Refactor</h2>

<p>I was ready to embark on this third post a while back but then I sat back and thought about how I might structure things if I were using another set of technologies. Usually I would put another layer between the web tier and the back-end database cluster as opposed to having the web tier talk to the database directly. It didn't make sense to me that this approach would be any different in Erlang.</p>

<p>I had a chat to <a href="http://twitter.com/sj_mackenzie" title="Stewart Mackenzie on Twitter">two</a> <a href="http://twitter.com/MatthewErbs" title="Matt Erbs on Twitter">blokes</a> that I really respect to get their views, and then I fired off a question to the Basho guys (via the <a href="irc://irc.freenode.com/riak" title="Riak IRC on Freenode">#riak IRC channel</a>). The Basho lads even made the effort to respond to me via the <a href="http://lists.basho.com/pipermail/riak-users_lists.basho.com/2010-September/001984.html" title="Riak Recap">Riak Recap</a> as they weren't available at the time to answer me via IRC (thanks again <a href="http://twitter.com/pharkmillups" title="Mark Phillips on Twitter">Mark</a>). All three of them confirmed my thoughts. Here's what appeared in the recap which captures the question and response nicely:</p>

<blockquote><p>Q --- I have a Webmachine application which will be talking to Riak. I was going to put application and controller logic in that application and I am wondering if [I] should instead be creating a "core" OTP application with the business style logic in it and have the Webmachine app talk to that app which, in turn, talks to Riak? Is that the general approach that is taken [in Erlang applications]? (from TheColonial via #riak)</p>

<p>A --- We recommend going with the latter approach. You're better off to create a core app that talks to Webmachine and Riak separately.</p></blockquote>

<p>Perfect, that makes total sense. Therefore the following describes what I did to modify the code base that I had in order to support this set up. <strong>Any failure</strong> in implementation, structure or understanding is totally my own and in no way reflects on the abilities and advice of those mentioned above who took the time to offer assistance.</p>

<p>Moving on. What we want to end up with is three applications:</p>

<table cellspacing="0">
  <thead>
    <tr>
      <th style="text-align:center;">Application</th>
      <th style="text-align:center;">Structure/Responsibility</th>
      <th style="text-align:center;">Talks to</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Riak</td>
      <td>Bomb-proof data storage and replication.</td>
      <td style="text-align:center">-</td>
    </tr>
    <tr>
      <td>csd_core</td>
      <td>An OTP application that provides an API to a set of logic that deals with the transformation of data from a client through to the database. It should keep the clients ignorant of the data storage medium. It should provide business logic that would be required for any client application to be able to talk to a `csd`/Riak back-end.</td>
      <td style="text-align:center">Riak</td>
    </tr>
    <tr>
      <td>csd_web</td>
      <td>Provide a nice, web-based interface for the user to experience the goal of the Code Smackdown application.</td>
      <td style="text-align:center">csd_core</td>
    </tr>
  </tbody>
</table>


<p>Given that we're going to be using this structure, the "root" folder should actually be fairly clean without any source. Instead, each <code>csd</code>-related application should live in its own sub-folder under an <code>apps</code> folder and the root should just contain the means to build it and start it. In essence what we'd like to see in the root folder is something like this:</p>

<pre><code>oj@spawn-link ~/blog/csd $ ls -F
apps/  dev.haproxy.conf  Makefile  proxy.sh*  rebar*  rebar.config  start.sh*
</code></pre>

<p>With that in mind, let's start the surgery.</p>

<h3>Moving csd to csd_web</h3>

<p>There are two ways to approach this problem. The first is to do a <strong>find and replace</strong>, making sure you cover off file names as well as module names, etc. The second is to simply <strong>recreate the web site from scratch</strong>, copy over any missing files and make any other adjustments manually that may be required.</p>

<p>I preferred the second approach, so that's what I did. First I recreated the web application, which is now called <code>csd_web</code> in the <code>apps</code> folder:</p>

<pre><code>oj@spawn-link ~/blog/csd $ mkdir apps &amp;&amp; cd apps
oj@spawn-link ~/blog/csd/apps $ ~/blog/webmachine/scripts/new_webmachine.sh csd_web .
==&gt; priv (create)
Writing /home/oj/blog/csd/apps/csd_web/README
Writing /home/oj/blog/csd/apps/csd_web/Makefile
Writing /home/oj/blog/csd/apps/csd_web/rebar.config
Writing /home/oj/blog/csd/apps/csd_web/rebar
Writing /home/oj/blog/csd/apps/csd_web/start.sh
Writing /home/oj/blog/csd/apps/csd_web/ebin/csd_web.app
Writing /home/oj/blog/csd/apps/csd_web/src/csd_web.erl
Writing /home/oj/blog/csd/apps/csd_web/src/csd_web_app.erl
Writing /home/oj/blog/csd/apps/csd_web/src/csd_web_sup.erl
Writing /home/oj/blog/csd/apps/csd_web/src/csd_web_resource.erl
Writing /home/oj/blog/csd/apps/csd_web/priv/dispatch.conf
oj@spawn-link ~/blog/csd/apps $ ls -F
csd_web/
</code></pre>

<p>Next I removed a few files which weren't going to be needed any more. I then copied over <code>rebar.config</code>, the ErlyDTL templates and the <code>csd.app.src</code> file (which we need to modify):</p>

<pre><code>oj@spawn-link ~/blog/csd/apps $ cd csd_web
oj@spawn-link ~/blog/csd/apps/csd_web $ rm README rebar start.sh
oj@spawn-link ~/blog/csd/apps/csd_web $ cp ../../rebar.config .
oj@spawn-link ~/blog/csd/apps/csd_web $ cp -R ../../templates .
oj@spawn-link ~/blog/csd/apps/csd_web $ cp ../../src/csd.app.src ./src/csd_web.app.src
</code></pre>

<p>I then edited the <code>csd_web.app.src</code> file so that the names were updated (I tidied it up a little and added a version number too):</p>

<p>{% codeblock apps/csd_web/src/csd_web.app.src lang:erlang %}
%%-<em>- mode: erlang -</em>-
{application, csd_web,
  [</p>

<pre><code>{description, "The Webmachine component of the Code Smackdown application."},
{vsn, "0.0.1"},
{modules, []},
{registered, []},
{applications,
  [
    kernel,
    stdlib,
    crypto,
    mochiweb,
    webmachine
  ]
},
{mod, {csd_web_app, []}},
{env, []}
</code></pre>

<p>  ]
}.
{% endcodeblock %}</p>

<p>I then opened up <code>csd_web_resource.erl</code> and made it look like the original <code>csd_resource.erl</code> so that it called the ErlyDTL template:</p>

<p>{% codeblock apps/csd_web/src/csd_web_resource.erl lang:erlang %}
-module(csd_web_resource).
-export([init/1, to_html/2]).</p>

<p>-include_lib("webmachine/include/webmachine.hrl").</p>

<p>init([]) ->
  {ok, undefined}.</p>

<p>to_html(ReqData, State) ->
  {ok, Content} = sample_dtl:render([{param, "Slartibartfast"}]),
  {Content, ReqData, State}.
{% endcodeblock %}</p>

<p><code>csd_web</code> is now ready to go. To build it, we need to go back up to the root <code>csd</code> folder and adjust the <code>rebar.config</code> so that it knows to look in the <code>apps</code> sub-folder (thanks to <a href="http://twitter.com/andrewtj" title="AndrewTJ on Twitter">Andrew</a> for <a href="http://lists.basho.com/pipermail/rebar_lists.basho.com/2010-October/000246.html" title="Configuring the Rebar apps folder on Basho list">pointing this out</a>). We can also remove all the dependencies because that will be taken care of by <code>csd_web</code>:</p>

<p>{% codeblock rebar.config lang:erlang %}
%%-<em>- mode: erlang -</em>-
{sub_dirs, ["apps/csd_web"]}.
{% endcodeblock %}</p>

<p>Next, I removed all the other left-over stuff in the root folder that wasn't required any more (including the startup script):</p>

<pre><code>oj@spawn-link ~/blog/csd $ rm -rf README priv src templates start.sh
</code></pre>

<p>I then modify the <code>Makefile</code> so that it does a couple of other things:</p>

<ol>
<li>Includes a target which builds just the current applications <em>without</em> building the dependencies (this will make builds much quicker most of the time).</li>
<li>Includes a target which can start the web application, essentially replacing the original startup script. This target will be dependent on the previous target so that it is always up to date when running the application.</li>
<li>Includes targets which can start/stop <code>HAproxy</code>.</li>
</ol>


<p>{% codeblock Makefile %}
ERL ?= erl
APP = csd</p>

<p>.PHONY: deps</p>

<p>all: deps
  @./rebar compile</p>

<p>app:
  @./rebar compile skip_deps=true</p>

<p>deps:
  @./rebar get-deps</p>

<p>clean:
  @./rebar clean</p>

<p>distclean: clean
  @./rebar delete-deps</p>

<p>webstart: app
  exec erl -pa $(PWD)/apps/*/ebin -pa $(PWD)/deps/*/ebin -boot start_sasl -s reloader -s csd_web</p>

<p>proxystart:
  @haproxy -f dev.haproxy.conf
{% endcodeblock %}</p>

<p>All that is left to do is start <code>haproxy</code> and launch the application (make sure <code>Riak</code> is running first). These commands need to be done in two different terminal windows. First, start the proxy (note the use of <code>sudo</code> so that we can listen on port 80):</p>

<pre><code>oj@spawn-link ~/blog/csd $ sudo make proxystart
[2] 1935
Available polling systems :
     sepoll : pref=400,  test result OK
      epoll : pref=300,  test result OK
       poll : pref=200,  test result OK
     select : pref=150,  test result OK
Total: 4 (4 usable), will use sepoll.
Using sepoll() as the polling mechanism.
</code></pre>

<p>Then make and start the web application. We have to do a full <code>make</code> first time around so that all the dependencies are resolved:</p>

<pre><code>oj@spawn-link ~/blog/csd $ make &amp;&amp; make webstart

   ... snip ...

=PROGRESS REPORT==== 4-Apr-2011::21:04:18 ===
         application: csd_web
          started_at: nonode@nohost
</code></pre>

<p>Now we should be able to hit <a href="http://localhost/" title="localhost web app">localhost</a> and see the ErlyDTL template rendered in all its awesome, black-and-white glory:</p>

<p><img src="http://buffered.io/uploads/2010/10/localhost-slartibartfast.png" /></p>

<p>Refactor complete. Now let's start work on our new OTP application which will be responsible for talking to Riak.</p>

<p>If you need a break, now is the time to take it! Go freshen up, take a leak and refill your glass.</p>

<p>Ready to go again? Here we go ...</p>

<h3>Creating the csd_core OTP Application</h3>

<p>Creation of an OTP-compliant application is another job for <a href="http://www.basho.com/developers.html#Rebar" title="Rebar">Rebar</a> as it comes with a set of templates built-in. Unfortunately those template aren't 100% and hence don't do everything we need to do out of the box. But we shall use them as a starting point:</p>

<pre><code>oj@spawn-link ~/blog/csd $ mkdir apps/csd_core &amp;&amp; cd apps/csd_core
oj@spawn-link ~/blog/csd/apps/csd_core $ ../../rebar create-app appid=csd_core
==&gt; csd_core (create-app)
Writing src/csd_core.app.src
Writing src/csd_core_app.erl
Writing src/csd_core_sup.erl
</code></pre>

<p>We have a very simple application shell set up, but we need to do a bit more work to get it ready. First, let's create our base <code>csd_core.erl</code> module which is used to fire up our application. For this we will use <code>csd_web.erl</code> (the one which is part of our Webmachine application) as a template. Note that I've shuffled things around and removed some things that are not relevant:</p>

<p>{% codeblock apps/csd_core/src/csd_core.erl lang:erlang %}
%% @author OJ Reeves <a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#x6f;&#106;&#64;&#x62;&#x75;&#x66;&#x66;&#x65;&#114;&#x65;&#100;&#x2e;&#x69;&#111;">&#111;&#106;&#x40;&#x62;&#117;&#102;&#102;&#x65;&#114;&#x65;&#x64;&#x2e;&#105;&#x6f;</a>
%% @copyright 2011 OJ Reeves</p>

<p>%% @doc csd_core startup code</p>

<p>-module(csd_core).
-author('OJ Reeves <a href="&#x6d;&#x61;&#105;&#108;&#x74;&#111;&#58;&#x6f;&#x6a;&#x40;&#98;&#117;&#x66;&#102;&#x65;&#114;&#101;&#100;&#46;&#x69;&#x6f;">&#x6f;&#x6a;&#x40;&#98;&#117;&#x66;&#x66;&#x65;&#x72;&#x65;&#x64;&#46;&#x69;&#x6f;</a>').
-export([start/0, start_link/0, stop/0]).</p>

<p>ensure_started(App) -></p>

<pre><code>case application:start(App) of
    ok -&gt;
        ok;
    {error, {already_started, App}} -&gt;
        ok
end.
</code></pre>

<p>%% @spec start_link() -> {ok,Pid::pid()}
%% @doc Starts the app for inclusion in a supervisor tree
start_link() -></p>

<pre><code>ensure_started(crypto),
csd_core_sup:start_link().
</code></pre>

<p>%% @spec start() -> ok
%% @doc Start the csd_core server.
start() -></p>

<pre><code>ensure_started(crypto),
application:start(csd_core).
</code></pre>

<p>%% @spec stop() -> ok
%% @doc Stop the csd_core server.
stop() -></p>

<pre><code>Res = application:stop(csd_core),
application:stop(crypto),
Res.
</code></pre>

<p>{% endcodeblock %}</p>

<p>Next up, edit <code>csd_core.app.src</code> and add some application-specific information:</p>

<p>{% codeblock apps/csd_core/src/csd_core.app.src lang:erlang %}</p>

<p>{application, csd_core,
  [</p>

<pre><code>{description, "Core functionality for the Code Smackdown application."},
{vsn, "0.0.1"},
{registered, []},
{applications,
  [
    kernel,
    stdlib
  ]
},
{mod, {csd_core_app, []}},
{env, []}
</code></pre>

<p>  ]
}.
{% endcodeblock %}</p>

<p>We know that we'll be talking to Riak, so we need to make sure we've included the <code>riakc</code> (Riak client) dependency. Though I haven't yet talked about it, we'll also be using Mochiweb's <a href="https://github.com/mochi/mochiweb/blob/master/src/mochijson2.erl" title="Mochiweb's json module">mochijson2</a> module to help with handling JSON data, so we shall add this as a dependency to the application. Bear in mind this is already a dependency for the web component of the application, so we're not actually adding a <em>new</em> dependency to the overall application.</p>

<p>We can do this by creating a <code>rebar.config</code> in <code>apps/csd_core</code> and editing it to contain the following:</p>

<p>{% codeblock apps/csd_core/rebar.config lang:erlang %}
%%-<em>- mode: erlang -</em>-
{deps,
  [</p>

<pre><code>{mochiweb, "1.5.1", {git, "git://github.com/mochi/mochiweb", {tag, "1.5.1"}}},
{riakc, ".*", {git, "git://github.com/basho/riak-erlang-client", "HEAD"}}
</code></pre>

<p>  ]
}.
{% endcodeblock %}</p>

<p>Then we need to tell <code>rebar</code> to build this new application by adjusting the <code>rebar.config</code> in the <code>csd</code> root folder:</p>

<p>{% codeblock rebar.config lang:erlang %}
%%-<em>- mode: erlang -</em>-
{sub_dirs, ["apps/csd_core", "apps/csd_web"]}.
{% endcodeblock %}</p>

<p>Now we have enough to get the <code>csd_core</code> application started, even though it doesn't do anything. We just need to adjust our <code>Makefile</code> target so that it launches the <code>csd_core</code> application as well:</p>

<p>{% codeblock Makefile %}
ERL ?= erl
APP = csd</p>

<p>.PHONY: deps</p>

<p>all: deps
  @./rebar compile</p>

<p>app:
  @./rebar compile skip_deps=true</p>

<p>deps:
  @./rebar get-deps</p>

<p>clean:
  @./rebar clean</p>

<p>distclean: clean
  @./rebar delete-deps</p>

<p>webstart: app
  exec erl -pa $(PWD)/apps/*/ebin -pa $(PWD)/deps/*/ebin -boot start_sasl -s reloader -s csd_core -s csd_web</p>

<p>proxystart:
  @haproxy -f dev.haproxy.conf
{% endcodeblock %}</p>

<p>Then off we go:</p>

<pre><code>oj@spawn-link ~/blog/csd $ make webstart
==&gt; csd_core (compile)
Compiled src/csd_core_app.erl
Compiled src/csd_core_sup.erl
Compiled src/csd_core.erl

   ... snip ...

=PROGRESS REPORT==== 4-Apr-2011::21:49:27 ===
         application: csd_core
          started_at: nonode@nohost

   ... snip ...

=PROGRESS REPORT==== 4-Apr-2011::21:49:27 ===
         application: csd_web
          started_at: nonode@nohost
</code></pre>

<p>As you can see we now have a system which contains both <code>csd_core</code> and <code>csd_web</code>. This is great, but <code>csd_core</code> needs a lot more work. The intent for this application is to be an <a href="http://en.wikipedia.org/wiki/Open_Telecom_Platform" title="Open Telecom Platform">OTP</a> application which provides an API to the <code>csd</code> logic and back-end database. This means we're going to need to get ourselves a <a href="http://www.erlang.org/doc/design_principles/gen_server_concepts.html" title="gen_server behaviour">gen_server</a> set up which can handle requests from various clients. Let's do that next.</p>

<p>Thankfully <code>rebar</code> comes with a simple template that we can use for creating the <code>gen_server</code> behaviour, so we can invoke that from the command line and have it generate the shell for us:</p>

<pre><code>oj@spawn-link ~/blog/csd/apps/csd_core $ ../../rebar create template=simplesrv srvid=csd_core_server
==&gt; csd_core (create)
Writing src/csd_core_server.erl
</code></pre>

<p>We now have a very dumb server ready to go, to make it start with the rest of the application we have to modify <code>csd_core_sup</code>, the <a href="http://www.erlang.org/doc/design_principles/sup_princ.html" title="supervisor behaviour">supervisor</a> and tell it to fire up the server for us:</p>

<p>{% codeblock apps/csd_core/src/csd_core_sup.erl lang:erlang %}
-module(csd_core_sup).</p>

<p>-behaviour(supervisor).</p>

<p>%% API
-export([start_link/0]).</p>

<p>%% Supervisor callbacks
-export([init/1]).</p>

<p>%% Helper macro for declaring children of supervisor
-define(CHILD(I, Type), {I, {I, start_link, []}, permanent, 5000, Type, [I]}).</p>

<p>%% ===================================================================
%% API functions
%% ===================================================================</p>

<p>start_link() ->
  supervisor:start_link({local, ?MODULE}, ?MODULE, []).</p>

<p>%% ===================================================================
%% Supervisor callbacks
%% ===================================================================</p>

<p>init([]) ->
  Server = ?CHILD(csd_core_server, worker),
  Processes = [Server],
  {ok, { {one_for_one, 5, 10}, Processes} }.
{% endcodeblock %}</p>

<p>With this in place we can now start our application again and we should see the new <code>csd_core_server</code> appear in the start-up sequence:</p>

<pre><code>oj@spawn-link ~/blog/csd $ make webstart

   ... snip ...

=PROGRESS REPORT==== 4-Apr-2011::22:04:04 ===
          supervisor: {local,csd_core_sup}
             started: [{pid,&lt;0.54.0&gt;},
                       {name,csd_core_server},
                       {mfargs,{csd_core_server,start_link,[]}},
                       {restart_type,permanent},
                       {shutdown,5000},
                       {child_type,worker}]

=PROGRESS REPORT==== 4-Apr-2011::22:04:04 ===
         application: csd_core
          started_at: nonode@nohost

   ... snip ...
</code></pre>

<p>The shell and structure of our application is now in place. We are finally ready to start talking to Riak!</p>

<p>Again, now is the time to have a mini-break if you need one. Grab a <em>Shigar und a waffle</em> and a cup of English Breakfast tea.</p>

<h2>Preparing csd_core for Riak connectivity</h2>

<p>Given that this is the first look at connecting to Riak, we're going to have to set up a little infrastructure to support our needs. As a result, the data itself won't be discussed much for fear of turning this post into something way more epic than originally intended.</p>

<p>So in short, we're interested in storing the idea of a <em>code snippet</em>. That is an entity which contains two opposing blobs of code which are being compared. That snippet will have a title. Down the track, more information will be associated with this snippet, such as the author, along with links to a set of comments and votes. For now we'll just focus on storing the bare essentials of the snippet.</p>

<h3>The Snippet</h3>

<p>As far as our Erlang code is concerned, our snippet is going to be a simple list of properties that we can interact with via the <a href="http://www.erlang.org/doc/man/proplists.html" title="proplists">proplists</a> module. This keeps things really simple. To demonstrate what our snippet will look like in code, here is the function that takes a Title, and the two code blobs (called Left and Right) and returns a <code>snippet</code> instance. This code goes in a module called <code>csd_snippet</code> defined in <code>src/csd_snippet.erl</code>:</p>

<p>{% codeblock apps/csd_core/src/csd_snippet.erl (part) lang:erlang %}
to_snippet(Title, Left, Right) ->
  {snippet,</p>

<pre><code>[
  {title, Title},
  {left, Left},
  {right, Right}
]
</code></pre>

<p>  }.
{% endcodeblock %}</p>

<p>Note that the first part of the tuple is the atom <code>snippet</code> which I am using to identify the layout of the contents in the second part of the tuple. Down the track we'll have more collections of data in the system than just snippets, and we may want to make sure that the caller doesn't accidentally pass in a <code>user</code>, for example, to a function expecting a <code>snippet</code>.</p>

<p>It is important at this point to note that, down the track, I will include a <code>key</code> property in all of the data objects that are pushed to Riak. This property serves as the identifier for the object in Riak and is stored alongside the rest of the data so that it is easy to relate the in-memory instance back to the stored instance. This value, if not specified, will be inserted automatically when an item is saved via the API functions in <code>csd_core</code>. More on this later.</p>

<h3>Formatting Data for Storage in Riak</h3>

<p>Riak is very flexible in that it will store whatever kind of information you give it. This is good because it means we can cater our data format to whatever needs we have.</p>

<p>In our case, the <em>easiest</em> option would be to store our Erlang terms as binary using <a href="http://www.erlang.org/doc/man/erlang.html#term_to_binary-1" title="term_to_binary">term_to_binary</a> as we wouldn't have to think about <em>anything</em> else. We could easily read the data using <a href="http://www.erlang.org/doc/man/erlang.html#binary_to_term-1" title="binary_to_term">binary_to_term</a>. Done.</p>

<p>This comes with a set of problems though. For example, if we wanted to <a href="http://en.wikipedia.org/wiki/MapReduce" title="map/reduce">map/reduce</a> using JavaScript we wouldn't find it easy to get the data into a format that we could use. Another example would be that the RESTful interface to Riak would be close to useless because <strong>any</strong> non-Erlang client would have to somehow get the data into a meaningful format to work with.</p>

<p>Instead of using binary and throwing Erlang terms straight into Riak, we're going to use <a href="http://json.org/" title="JavaScript Object Notation">JSON</a>. It's very easy to convert to and from JSON in many different languages, and it's very easy to read. We can also easily verify that the data is being stored correctly by querying Riak's RESTful interface directly using <a href="http://curl.haxx.se/" title="cURL homepage">cURL</a> or a browser.</p>

<p>In order to store data in JSON format, we're going to enlist the help of <a href="https://github.com/mochi/mochiweb/blob/master/src/mochijson2.erl" title="Mochiweb's json module">mochijson2</a>, a library that comes with <a href="https://github.com/mochi/mochiweb" title="Mochiweb">Mochiweb</a> that makes it a <em>lot</em> easier to deal with JSON than doing everything manually. Given that we're using Webmachine for the front-end (which itself relies on Mochiweb) we already have the dependency available.</p>

<p>Unfortunately we can't just throw our data straight at this module and have it do everything for us. <code>mochijson2</code> requires data to be in a certain format before it can encode it to JSON. When decoding <em>from</em> JSON, it converts the data into the same format. Hence, we need the ability to convert our own data format to and from this intermediate data format so that <code>mochijson2</code> can deal with it.</p>

<p>We need two functions: <code>to_json()</code> and <code>from_json()</code>, and we shall define these in a helper module called <code>csd_json</code>. This module will live in <code>csd_core</code>:</p>

<p>{% codeblock apps/csd_core/src/csd_json.erl (part) lang:erlang %}
-module(csd_json).
-export([from_json/1, from_json/2, to_json/1, to_json/2]).</p>

<p>to_json(PropList) ->
  to_json(PropList, fun(_) -> true end).</p>

<p>to_json(PropList, IsStrFun) ->
  list_to_binary(mochijson2:encode(from_proplist(PropList, IsStrFun))).</p>

<p>from_json(Json) ->
  from_json(Json, fun(_) -> true end).</p>

<p>from_json(Json, IsStrFun) ->
  to_proplist(mochijson2:decode(Json), IsStrFun).
{% endcodeblock %}</p>

<p>You're probably wondering why each of these functions requires the <code>IsStrFun</code> parameter (if you're not, you're obviously an experienced Erlanger!). For those who don't know, strings in Erlang are actually lists of integers. This is fantastic as it makes it easy to manipulate strings as if they were lists, but it comes at a small price: it's not possible to determine the difference between a list of integers and a string.</p>

<p>Why is this important? <code>mochijson2</code> needs strings to be encoded as binaries, so we need a way to differentiate between integer lists and real strings. My original implementations of both the <code>to_json()</code> and <code>from_json()</code> functions attempted to figure out if certain fields were strings or not by looking at the content of the list. Not only was the code messy, but it wasn't foolproof. Instead, I made the decision to force the user to provide a callback function which will tell the JSON serialiser if the given property is a string or not. This callback takes a single parameter which is the name (in atom form) of the property and returns a boolean -- <code>true</code> indicates that the value is a string, <code>false</code> otherwise.</p>

<p>In some cases we might just be happy to encode/decode every single value as a string. Hence, there is an overload to both <code>to_json()</code> and <code>from_json()</code> which caters for this case. The rest of the code which implments the conversion is listed below. Don't feel that you need to understand the code below, as it's really not the goal of this post. The full source to this module is included in the source link specified at the end of this post.</p>

<p>{% codeblock apps/csd_core/src/csd_json.erl (part) lang:erlang %}
from_proplist(List=[H|<em>], IsStrFun) when is_tuple(H) ->
  { struct, lists:map(fun(P) -> from_proplist(P, IsStrFun) end, List) };
from_proplist({PropName, ComplexProp=[H|</em>]}, IsStrFun) when is_tuple(H) ->
  { list_to_binary(atom_to_list(PropName)), from_proplist(ComplexProp, IsStrFun) };
from_proplist({PropName, PropVal}, IsStrFun) ->
  { list_to_binary(atom_to_list(PropName)), to_value(PropName, PropVal, IsStrFun) }.</p>

<p>to_proplist({struct, PropList}, IsStrFun) when is_list(PropList) ->
  lists:map(fun(P) -> to_proplist(P, IsStrFun) end, PropList);
to_proplist({PropName, ComplexProp={struct, _}}, IsStrFun) ->
  { list_to_atom(binary_to_list(PropName)), to_proplist(ComplexProp, IsStrFun) };
to_proplist({PropName, PropVal}, IsStrFun) ->
  PropAtom = list_to_atom(binary_to_list(PropName)),
  { PropAtom, from_value(PropAtom, PropVal, IsStrFun) }.</p>

<p>to_value(PropName, L=[H|_], IsStrFun) when is_list(L) and is_list(H) ->
  lists:map(fun(P) -> to_value(PropName, P, IsStrFun) end, L);
to_value(PropName, L, IsStrFun) when is_list(L) ->
  case IsStrFun(PropName) of</p>

<pre><code>true -&gt; list_to_binary(L);
_ -&gt; lists:map(fun(V) -&gt; to_value(PropName, V, IsStrFun) end, L)
</code></pre>

<p>  end;
to_value(<em>, V, </em>) ->
  V.</p>

<p>from_value(PropName, L, IsStrFun) when is_list(L) ->
  lists:map(fun(P) -> from_value(PropName, P, IsStrFun) end, L);
from_value(PropName, B, IsStrFun) when is_binary(B) ->
  case IsStrFun(PropName) of</p>

<pre><code>true -&gt; binary_to_list(B);
_ -&gt; B
</code></pre>

<p>  end;
from_value(<em>, V, </em>) ->
  V.
{% endcodeblock %}</p>

<p>We are now able to read and write data to and from JSON format. Now we need to use the Riak client to push that into our Riak cluster.</p>

<h3>Setting up the Riak client</h3>

<p>Basho have done a great job of creating a protocol buffer-based client for use with Riak. The interface is really simple to use. Despite that, we shall create a module which will deal with this for us. This gives us a single point of abstraction of Riak and a place where we can add extra support for our own needs without spreading Riak-specific code all over the source base.</p>

<p>The first problem we need to resolve is: <em>what do we do with configuration?</em></p>

<p>This was a question I initially didn't know how to answer. After a bit of deliberation and a chat with a <a href="http://twitter.com/mononcqc" title="Ferd T-H on Twitter">respected Erlang sifu</a> (who has a <a href="http://learnyousomeerlang.com/" title="Learng you some erlang">fantastic Erlang tutorial site</a>) I decided to go with a module-based option.</p>

<p>We have our Riak cluster hidden behind the <code>haproxy</code> load balancer, and hence we have a single entry-point to connect to. If this entry-point changes, it changes for all of the clients, not just a single client. Therefore, I want the ability to manage a single set of connection information, but I want the ability to update it on the fly without having to restart the <code>csd_core</code> application. This is Erlang, after all, and modifying code and configuration on-the-fly is extremely easy. We shall abuse that.</p>

<p>We create a single module, <code>csd_riak_config.erl</code>, to contain our configuration which is referenced at start-up. It looks like this:</p>

<p>{% codeblock apps/csd_core/src/csd_riak_config.erl lang:erlang %}
-module(csd_riak_config).
-export([connection_info/0]).</p>

<p>connection_info() ->
  { "127.0.0.1", 8080 }.
{% endcodeblock %}</p>

<p>Pretty simple stuff. Let's use this functionality in our <code>gen_server</code>, and carry the configuration through from initialisation to all of the calls that will be made to the Riak server. This requires two simple modifications to the <code>csd_core_server</code> module:</p>

<p>{% codeblock apps/csd_core/src/csd_core_server.erl (part) lang:erlang %}
start_link() ->
  ConnInfo = csd_riak_config:connection_info(),
  gen_server:start_link({local, ?SERVER}, ?MODULE, [ConnInfo], []).</p>

<p>% ...</p>

<p>init([ConnInfo]) ->
  {ok, ConnInfo}.
{% endcodeblock %}</p>

<p>Confiuration is now loaded and is being passed to all of our <code>gen_server</code> callbacks. Let's make use of it. <code>csd_snippet</code> is the entry point for all snippet-related information, and one of the things that we are going to want to be able to do is write a snippet to Riak. So let's create a code-path that can do that.</p>

<h4>Writing Data to Riak</h4>

<p>The first point of call for a client is the OTP interface. Let's create an API call and a call handler to support saving snippets in <code>csd_core_server</code>:</p>

<p>{% codeblock apps/csd_core/src/csd_core_server.erl (part) lang:erlang %}</p>

<p>%% This is a simple function which invokes a call via the gen_sever
%% behaviour.
save_snippet(Snippet) ->
  gen_server:call(?SERVER, {save_snippet, Snippet}, infinity).</p>

<p>%% Handle the case where a caller wants to save a snippet to Riak. We
%% create a connection to Riak and pass that into the snippet handler
%% along with the snippet that needs to be saved. We return the newly
%% saved snippet.
handle_call({save_snippet, Snippet}, _From, ConnInfo) ->
  RiakPid = csd_riak:connect(ConnInfo),
  SavedSnippet = csd_snippet:save(RiakPid, Snippet),
  {reply, SavedSnippet, ConnInfo};
{% endcodeblock %}</p>

<p>Of course, we will need to export the <code>save_snippet()</code> function if we want to be able to call it.</p>

<p>You'll notice that we're getting the connection information passed in as the state for the OTP call, and that we're using that to create a connection to Riak via the <code>csd_riak</code> module. We shall cover this module in just a minute, but hopefully the interface to this function should make it relatively self-explanatory.</p>

<p>You might be wondering "Why are you creating the Riak client connection here instead of letting the <code>csd_snippet:save()</code> function do it by itself. It's a good question. The reason I decided to create the connection as part of OTP call rather than in the data/helper modules is because down the track there will probably be a need to do multiple interactions with Riak in a single call. If we force each of the called modules, such as <code>csd_snippet</code>, to establish their own connections then we'd probably have <em>multiple connections to Riak being created during a single client request</em>. This isn't what I would like to see happen, so it made sense (in my view) to create the client connection once and reuse it across all modules that are invoked during the request.</p>

<p>With that out of the way, we need to implement the <code>save()</code> function in the <code>csd_snippet</code> module. Brace yourself:</p>

<p><span class="filename"></span>
{% codeblock apps/csd_core/src/csd_snippet.erl (part) lang:erlang %}
save(RiakPid, Snippet={snippet, SnippetData}) ->
  case proplists:get_value(key, SnippetData, undefined) of</p>

<pre><code>undefined -&gt;
  Key = csd_riak:new_key(),
  NewSnippetData = [{key, Key} | SnippetData],
  RiakObj = csd_riak:create(?BUCKET, Key, to_json_internal(NewSnippetData)),
  ok = csd_riak:save(RiakPid, RiakObj),
  {snippet, NewSnippetData};
ExistingKey -&gt;
  RiakObj = csd_riak:fetch(RiakPid, ?BUCKET, ExistingKey),
  NewRiakObj = csd_riak:update(RiakObj, to_json_internal(SnippetData)),
  ok = csd_riak:save(RiakPid, NewRiakObj),
  Snippet
</code></pre>

<p>  end.
{% endcodeblock %}</p>

<p>On the surface this looks a little complicated, but it's actually very simple. As mentioned earlier in the post, we use a <code>key</code> property to store the identifier of the object in Riak. This code supports this notion. It works as follows:</p>

<ol>
<li><strong>Try to get the value of the <code>key</code> from the given list of properties.</strong></li>
<li><strong>If <em>not</em> found ...</strong>

<ol>
<li>create a new key using the <code>new_key()</code> function in the <code>csd_riak</code> module (this will be covered shortly).</li>
<li>Add the <code>key</code> to the list of properties for the snippet.</li>
<li>Create a new instance of a Riak object (more on this later) which contains the details of the snippet data to be written, along with the target bucket name and the key of the snippet.</li>
<li>Save the Riak object to the Riak cluster using the specified Riak client connection (Pid), and for now assume that it succeeds.</li>
<li>Return the new set of snippet data with the snippet's key included.</li>
</ol>
</li>
<li><strong>If found ...</strong>

<ol>
<li>Load the existing data from the Riak cluster into a Riak object.</li>
<li>Update the Riak object with the new data values passed into the function.</li>
<li>Save the Riak object <em>back</em> to the Riak cluster using the specified Riak client connection (Pid), and for now assume that it succeeds.</li>
<li>Return the snippet back to the caller as is.</li>
</ol>
</li>
</ol>


<p>It's fairly basic functionality which does enough to cater for our needs at this point. Through this one function, we can write new snippet instances to Riak, and we can update them too.</p>

<p>You'll also notice that another function is being called that hasn't been discussed: <code>to_snippet_internal()</code>. Rather than try to explain this, let's see the code as it's quite easy to follow:</p>

<p>{% codeblock apps/csd_core/src/csd_snippet.erl (part) lang:erlang %}
%% exported functions
to_json({snippet, SnippetData}) ->
  to_json_internal(SnippetData).</p>

<p>from_json(SnippetJson) ->
  from_json_internal(SnippetJson).</p>

<p>%% helper functions used internally.
to_json_internal(SnippetData) ->
  csd_json:to_json(SnippetData, fun is_string/1).</p>

<p>from_json_internal(SnippetJson) ->
  {snippet, csd_json:from_json(SnippetJson, fun is_string/1)}.</p>

<p>is_string(title) -> true;
is_string(left) -> true;
is_string(right) -> true;
is_string(_) -> false.
{% endcodeblock %}</p>

<p>As you can see, these are helper functions which call the <code>csd_json</code> functions to serialise/deserialise to/from JSON format. The <code>is_string()</code> function is the one that is used to tell the JSON functionality which properties are strings and which are not. At the moment, all properties defined on the snippet are string properties. Bear in mind that the <code>key</code> property, which is added automatically, is <em>not</em> a string.</p>

<p>All that is left is to see how <code>csd_riak</code> deals with the underlying Riak connectivity. Prepare to be underwhelmed!</p>

<p>{% codeblock apps/csd_core/src/csd_riak.erl lang:erlang %}
%% @spec connect(connection_info()) -> pid()
%% @doc Create a connection to the specified Riak cluster and
%%      return the Pid associated with the new connection.
connect({IP, Port}) ->
  {ok, RiakPid} = riakc_pb_socket:start_link(IP, Port),
  RiakPid.</p>

<p>%% @spec create(binary, binary, json) -> riakc_obj()
%% @doc Create a new instance of a riak object using the
%%      parameters given. The riak object can then be
%%      persisted to a Riak node/cluster. This overload
%%      assumes that the data passed in is JSON and sets
%%      the MIME type to "application/json" for you.
create(Bucket, Key, JsonData) ->
  create(Bucket, Key, JsonData, "application/json").</p>

<p>%% @spec create(binary, binary, term(), string) -> riakc_obj()
%% @doc Create a new instance of a riak object using the
%%      parameters given. The riak object can then be
%%      persisted to a Riak node/cluster. This overload
%%      takes arbitrary data and requires the user to
%%      specify the mime type of the data that is being
%%      stored.
create(Bucket, Key, Item, MimeType) ->
  RiakObj = riakc_obj:new(Bucket, Key, Item, MimeType),
  RiakObj.</p>

<p>%% @spec fetch(pid(), binary, binary) -> riakc_obj()
%% @doc Fetches a riakc object from a Riak node/cluster
%%      using the connection given.
fetch(RiakPid, Bucket, Key) ->
  RiakObj = riakc_pb_socket:get(RiakPid, Bucket, Key),
  RiakObj.</p>

<p>%% @spec update(riakc_obj(), term()) -> riakc_obj()
%% @doc Updates the stored value for a riakc object with
%%      the new one specified.
update(RiakObj, NewValue) ->
  NewRiakObj = riakc_obj:update_value(RiakObj, NewValue),
  NewRiakObj.</p>

<p>%% @spec get_value(riakc_obj()) -> term()
%% @doc Retrieves the stored value from within the riakc
%%      object.
get_value(RiakObj) ->
  Value = riakc_obj:get_value(RiakObj),
  Value.</p>

<p>%% @spec save(pid(), riakc_obj()) -> {ok, riakc_obj()} | {error | Reason}
%% @doc Saves the given riak object to the specified Riak node/cluster.
save(RiakPid, RiakObj) ->
  Result = riakc_pb_socket:put(RiakPid, RiakObj),
  Result.</p>

<p>%% @spec new_key() -> key()
%% @doc Generate an close-to-unique key that can be used to identify
%%      an object in riak. This implementation is blatantly borrowed
%%      (purloined) from the wriaki source (thanks basho!)
new_key() ->
  { {Yr, Mo, Dy}, {Hr, Mn, Sc} } = erlang:universaltime(),
  {<em>, </em>, Now} = now(),
  new_key([Yr, Mo, Dy, Hr, Mn, Sc, node(), Now]).</p>

<p>%% @spec new_key(list()) -> key()
%% @doc Generate an close-to-unique key that can be used to identify
%%      an object in riak using the given list parameter as the stuff
%%      to hash.
new_key(List) ->
  Hash = erlang:phash2(List),
  base64:encode(&lt;&lt;Hash:32>>).
{% endcodeblock %}</p>

<p>Hopefully the code in this module is fairly self-explanatory. It's a very simple API to follow which made it very easy to build. So with this in place, let's fire up the application, create a new snippet and see if it lands in the Riak store:</p>

<pre><code>oj@spawn-link  ~/blog/csd $ make webstart

   ... snip ...

=PROGRESS REPORT==== 4-Apr-2011::22:54:55 ===
         application: csd_web
          started_at: nonode@nohost

1&gt; Snippet = csd_snippet:to_snippet(
1&gt; "Super composition!",
1&gt; "(.^) = (.) . (.)",
1&gt; "(.^) = fmap `fmap` fmap").
{snippet,[{title,"Super composition!"},
          {left,"(.^) = (.) . (.)"},
          {right,"(.^) = fmap `fmap` fmap"}]}
2&gt; SavedSnippet = csd_core_server:save_snippet(Snippet).

PROGRESS REPORT==== 4-Apr-2011::22:57:13 ===
          supervisor: {local,inet_gethost_native_sup}
             started: [{pid,&lt;0.103.0&gt;},{mfa,{inet_gethost_native,init,[[]]}}]

=PROGRESS REPORT==== 4-Apr-2011::22:57:13 ===
          supervisor: {local,kernel_safe_sup}
             started: [{pid,&lt;0.102.0&gt;},
                       {name,inet_gethost_native_sup},
                       {mfargs,{inet_gethost_native,start_link,[]}},
                       {restart_type,temporary},
                       {shutdown,1000},
                       {child_type,worker}]
{snippet,[{key,&lt;&lt;"B41kUQ=="&gt;&gt;},
          {title,"Super composition!"},
          {left,"(.^) = (.) . (.)"},
          {right,"(.^) = fmap `fmap` fmap"}]}
</code></pre>

<p>As you can see from the above script dump, a new <code>key</code> was generated for us and stored alongside the snippet (it's highlighted in bold). Verifying that the data has persisted is simple. We can hit any of the Riak nodes via its web interface. Let's take a look at <strong>http://localhost:8091/riak/snippet/B41kUQ==</strong> (your URL will have a different key):</p>

<p><img src="http://buffered.io/uploads/2010/10/localhost-verify-write.png" /></p>

<p>Great stuff! For more detail, let's see what cURL has to say:</p>

<pre><code>oj@spawn-link ~/blog/csd/ $ curl http://localhost:8091/riak/snippet/B41kUQ== -v
* About to connect() to localhost port 8091 (#0)
*   Trying ::1... Connection refused
*   Trying 127.0.0.1... connected
* Connected to localhost (127.0.0.1) port 8091 (#0)
&gt; GET /riak/snippet/B41kUQ== HTTP/1.1
&gt; User-Agent: curl/7.21.0 (x86_64-pc-linux-gnu) libcurl/7.21.0 OpenSSL/0.9.8o zlib/1.2.3.4 libidn/1.18
&gt; Host: localhost:8091
&gt; Accept: */*
&gt; 
&lt; HTTP/1.1 200 OK
&lt; X-Riak-Vclock: a85hYGBgzGDKBVIsjOy7jmcwJTLmsTJ8tuc7zpcFAA==
&lt; Vary: Accept-Encoding
&lt; Server: MochiWeb/1.1 WebMachine/1.7.3 (participate in the frantic)
&lt; Link: &lt;/riak/snippet&gt;; rel="up"
&lt; Last-Modified: Mon, 04 Apr 2011 13:13:23 GMT
&lt; ETag: "6fw7c5v4IPAsf4B5hMHybc"
&lt; Date: Mon, 04 Apr 2011 13:13:36 GMT
&lt; Content-Type: application/json
&lt; Content-Length: 107
&lt; 
* Connection #0 to host localhost left intact
* Closing connection #0
{"key":"B41kUQ==","title":"Super composition!","left":"(.^) = (.) . (.)","right":"(.^) = fmap `fmap` fmap"}
</code></pre>

<p>As you can see, it has not only serialised to JSON properly, but the MIME type has been set correctly as well.</p>

<p>This is all well and good, but we need our code to be able to read from Riak as well. That's up next.</p>

<h4>Reading Data from Riak</h4>

<p>We've already covered off what happens at the bottom level when reading data from Riak (see the above code snippet for more info). To enable this functionality at the top level, we simply need to create a <code>gen_server</code> call, handle it appropriately and expose a function in the <code>csd_snippet</code> module. Let's start at the top level:</p>

<p>{% codeblock - apps/csd_core/src/csd_core_server.erl (part) lang:erlang %}
%% OTP API function to get a snippet based on the key
get_snippet(SnippetKey) ->
  gen_server:call(?SERVER, {get_snippet, SnippetKey}, infinity).</p>

<p>%% handle the call and call the functionality from csd_snippet
handle_call({get_snippet, SnippetKey}, _From, ConnInfo) ->
  RiakPid = csd_riak:connect(ConnInfo),
  Snippet = csd_snippet:fetch(RiakPid, SnippetKey),
  {reply, Snippet, ConnInfo};
{% endcodeblock %}</p>

<p>This code is a bit of a no-brainer. It's very similar to the writing code, but just a bit simpler. Let's see what the <code>csd_snippet:fetch()</code> function looks like:</p>

<p>{% codeblock apps/csd_core/src/csd_snippet.erl (part) lang:erlang %}
fetch(RiakPid, Key) ->
  {ok, RiakObj} = csd_riak:fetch(RiakPid, ?BUCKET, Key),
  SnippetJson = csd_riak:get_value(RiakObj),
  from_json_internal(SnippetJson).
{% endcodeblock %}</p>

<p>This code just pulls a Riak object out of the back-end, extracts is value and deserialises it from JSON to our Erlang <code>proplist</code>. Very simple stuff.</p>

<p>We should be able to build this and, via the Erlang console, verify that it functions:</p>

<pre><code>3&gt; Reloading csd_core_server ... ok.
3&gt; csd_core_server:get_snippet(&lt;&lt;"B41kUQ=="&gt;&gt;).
{snippet,[{key,&lt;&lt;"B41kUQ=="&gt;&gt;},
          {title,"Super composition!"},
          {left,"(.^) = (.) . (.)"},
          {right,"(.^) = fmap `fmap` fmap"}]}
</code></pre>

<p>Works like a charm. Now, for the icing on the cake, let's get this rendering in a very simple template in our browser.</p>

<h3>End to End</h3>

<p>In order to gain access to our data in Riak from the web we need to create a new resource. This resource will respond to any URI of the form <code>/snippet/&lt;key&gt;</code>. We shall call this resource <code>csd_web_snippet_resource</code> and we'll be putting this in our web application. It looks like this:</p>

<p>{% codeblock apps/csd_web/src/csd_web_snippet_resource.erl lang:erlang %}
%% @author OJ Reeves <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#x6f;&#x3a;&#x6f;&#106;&#x40;&#x62;&#117;&#102;&#x66;&#x65;&#x72;&#101;&#100;&#x2e;&#105;&#111;">&#x6f;&#x6a;&#x40;&#98;&#117;&#102;&#x66;&#101;&#114;&#x65;&#x64;&#46;&#105;&#111;</a>
%% @copyright 2010 OJ Reeves
%% @doc Webmachine resource that handles snippet-related actions</p>

<p>-module(csd_web_snippet_resource).
-author('OJ Reeves <a href="&#x6d;&#x61;&#x69;&#x6c;&#x74;&#111;&#58;&#111;&#106;&#x40;&#x62;&#117;&#x66;&#x66;&#x65;&#x72;&#x65;&#100;&#46;&#105;&#111;">&#111;&#x6a;&#64;&#98;&#x75;&#x66;&#102;&#x65;&#x72;&#101;&#100;&#x2e;&#x69;&#x6f;</a>').</p>

<p>-export([init/1, to_html/2]).</p>

<p>-include_lib("webmachine/include/webmachine.hrl").</p>

<p>init([]) -> {ok, undefined}.</p>

<p>to_html(ReqData, State) ->
  PathInfo = wrq:path_info(ReqData),
  {ok, SnippetKey} = dict:find(key, PathInfo),
  {snippet, SnippetData} = csd_core_server:get_snippet(list_to_binary(SnippetKey)),
  {ok, Content} = snippet_dtl:render(SnippetData),
  {Content, ReqData, State}.
{% endcodeblock %}</p>

<p>As you can see, this code calls through to the <code>csd_core_server</code> to extract the data from the back-end. The value that is used as a key for the snippet is one that is pulled from the URI via Webmachine's <code>wrq:path_info()</code> function. This function extracts values from the URI based on the rules in <code>dispatch.conf</code> and provides a <a href="http://www.erlang.org/doc/man/dict.html" title="Erlang dict">dict</a> which can be used to lookup the values.</p>

<p>The code also uses a new ErlyDTL template called <code>snippet</code>. We'd best add that to the <code>templates</code> folder:</p>

<p>{% codeblock apps/csd_web/templates/snippet.dtl lang:html %}</p>

<!-- TODO : get the templating engine to stop ripping out the inline template code -->


<p><html>
  <body></p>

<pre><code>&lt;h1&gt;Snippet View&lt;/h1&gt;
&lt;h2&gt;{{ "{{ title "}} }}&lt;/h2&gt;
&lt;p&gt;Left: {{ "{{ left "}} }}&lt;/p&gt;
&lt;p&gt;Right: {{ "{{ right "}} }}&lt;/p&gt;
</code></pre>

<p>  </body>
</html>
{% endcodeblock %}</p>

<p>Finally, we just need to adjust <code>dispatch.conf</code> to include the new route handler so that our code gets called:</p>

<p>{% codeblock apps/csd_web/priv/dispatch.conf lang:erlang %}
%%-<em>- mode: erlang -</em>-
{[], csd_web_resource, []}.
{["snippet", key], csd_web_snippet_resource, []}.
{% endcodeblock %}</p>

<p>Note how <code>key</code> is specified alongside <code>"snippet"</code>. This means that the path following <code>snippet/</code> in the URI will be associated with the <code>key</code> atom in the <code>dict</code> generated by <code>wrq:path_info()</code>.</p>

<p>We're ready to rock. Rebuild, then hit the right URL, <strong>http://localhost/snippet/B41kUQ==</strong> (again, your key will be different), and you should get the following:</p>

<p><img src="http://buffered.io/uploads/2010/10/webmachine-to-riak.png" /></p>

<h2>Wrapping up</h2>

<p>Thanks for sticking with me! As you can see there is a little bit of ground-work required if you're interested in producing some form of structure that you can reuse all over your application, but the effort is definitely worth it. Now we have something in place which we can use to store arbitrarily complex <code>proplists</code> into Riak in JSON format, we have the ability to talk to Riak (read and write), and we have a proper application structure in place which we can build on.</p>

<p>Please note that the mechanism implemented in this post is quite simple and doesn't cover all cases that will be required before the application is complete. In future posts, this implementation will change to support more of those cases, such as dealing with concurrent updates, handling versions, etc.</p>

<p>Many thanks to those people who took the time out of their busy schedules to review my post before I shared it with the world. Those people shall remain nameless to protect them from any mistakes made in this post (which are solely my own).</p>

<p>As always, comments and feedback is welcomed and greatly appreciated. As are suggestions on improvements, pitfalls and blatant mistakes :)</p>

<p><strong>Note:</strong> The code for Part 3 (this post) can be found on <a href="https://bitbucket.org/OJ/csd/src/55fec468488c" title="Source code for Part 3">Github</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Webmachine, ErlyDTL and Riak - Part 2]]></title>
    <link href="http://buffered.io/posts/webmachine-erlydtl-and-riak-part-2/"/>
    <updated>2010-09-12T22:15:00+10:00</updated>
    <id>http://buffered.io/posts/webmachine-erlydtl-and-riak-part-2</id>
    <content type="html"><![CDATA[<p><img src="http://buffered.io/uploads/2010/09/riak-logo.png" alt="Riak Logo" style="float:left;padding-right:5px;padding-bottom:5px;"/>In <a href="/posts/webmachine-erlydtl-and-riak-part-1/" title="Wembachine, ErlyDTL and Riak - Part 1">Part 1</a> of the series we covered the basics of getting the development environment up and running. We also looked at how to get a really simple ErlyDTL template rendering. If you haven't yet gone through Part 1, I suggest you do that now. If you have, read on!</p>

<p>There are a few reasons this series is targeting this technology stack. One of them is <strong>uptime</strong>. We're aiming to build a site that stays up as much as possible. Given that, one of the things that I missed in the previous post was setting up a <a href="http://en.wikipedia.org/wiki/Load_balancing_(computing)" title="Load balancing">load balancer</a>. Hence this post will attempt to fill that gap.</p>

<!--more-->


<p>Any serious web-based application will have load-balancing in play somewhere. While not essential during development, it's handy to have a similar set up in the hope that it exposes you to some potential issues you might face when the application reaches production.</p>

<p>There are many high-quality load-balancing solutions out there to choose from. For this series, we shall be using <a href="http://haproxy.1wt.eu/" title="HAProxy">HAProxy</a>, which is a common choice amongst developers building scalable web applications. The rest of this post will cover how to set up HAProxy, verifying that the configuration is correct and confirming that it behaves appropriately when nodes in our cluster go down.</p>

<p>Please note the goal is to demonstrate how HAProxy <em>can</em> be configured. When deploying to your production environments please make sure the configuration matches your needs.</p>

<h3>HAProxy installation</h3>

<p>Let's start by pulling down the latest stable version of HAProxy's source, extracting it and building it. Here's a sample log of what you should expect:</p>

<pre><code>oj@nix ~/blog $ wget http://haproxy.1wt.eu/download/1.4/src/haproxy-1.4.14.tar.gz

  ... snip ...

oj@nix ~/blog $ tar -xzf haproxy-1.4.14.tar.gz 

  ... snip ...
</code></pre>

<p>At this point we've got the source and we're ready to make. HAProxy requires a parameter in order to build, and this parameter varies depending on your target system:</p>

<pre><code>oj@nix ~/blog $ cd haproxy-1.4.14
oj@nix ~/blog/haproxy-1.4.14 $ make

Due to too many reports of suboptimized setups, building without
specifying the target is no longer supported. Please specify the
target OS in the TARGET variable, in the following form:

   make TARGET=xxx

Please choose the target among the following supported list :

   linux26, linux24, linux24e, linux22, solaris
   freebsd, openbsd, cygwin, custom, generic

Use "generic" if you don't want any optimization, "custom" if you
want to precisely tweak every option, or choose the target which
matches your OS the most in order to gain the maximum performance
out of it. Please check the Makefile in case of doubts.
make: *** [all] Error 1
</code></pre>

<p>According to <a href="http://en.wikipedia.org/wiki/Uname" title="uname">uname</a>, I'm running Linux Kernel 2.6:</p>

<pre><code>oj@nix ~/blog/haproxy-1.4.14 $ uname -r
2.6.31-21-generic
</code></pre>

<p>As a result, I'll be passing in <strong>linux26</strong>. Make sure you specify the correct option depending on which system you are running. We'll be building it <em>and</em> installing it so that it can be called from anywhere:</p>

<pre><code>oj@nix ~/blog/haproxy-1.4.14 $ make TARGET=linux26

    ... snip ...

oj@nix ~/blog/haproxy-1.4.14 $ sudo make install

   ... snip ...
</code></pre>

<p>Simple! We now need to create a configuration for HAProxy which we can use during development. Not surprisingly, HAProxy can be run as a daemon, but it can also be invoked from the command line with a configuration passed as a parameter. For our development, we'll be executing from the command line as this will give us feedback/output on what's going on.</p>

<p>Let's create a file called <code>dev.haproxy.conf</code> inside our application directory so that it can be included in our source:</p>

<p>{% codeblock dev.haproxy.conf lang:bash %}</p>

<h1>start with the global settings which will</h1>

<h1>apply to all sections in the configuration.</h1>

<p>global
  # specify the maximum connections across the board
  maxconn 2048
  # enable debug output
  debug</p>

<h1>now set the default settings for each sub-section</h1>

<p>defaults
  # stick with http traffic
  mode http
  # set the number of times HAProxy should attempt to
  # connect to the target
  retries 3
  # specify the number of connections per front and
  # back end
  maxconn 1024
  # specify some timeouts (all in milliseconds)
  timeout connect 5000
  timeout client 50000
  timeout server 50000</p>

<h6>##### Webmachine Configuration</h6>

<h1>here is the first of the front-end sections.</h1>

<h1>this is where we specify our webmachine instances.</h1>

<h1>in our case we start with just one instance, but</h1>

<h1>we can add more later</h1>

<p>frontend webfarm
  # listen on port 80 across all network interfaces
  bind *:80
  # by default, point at our backend configuration
  # which lists our webmachine instances (this is
  # configured below in another section)
  default_backend webmachines</p>

<h1>this section indicates how the connectivity to</h1>

<h1>all the instances of webmachine should work.</h1>

<h1>Again, for dev there is only one instance, but</h1>

<h1>in production there would be more.</h1>

<p>backend webmachines
  # we'll specify a round-robin configuration in
  # case we add nodes down the track.
  balance roundrobin
  # enable the "X-Forware-For" header so that
  # we can see the client's IP in Webmachine,
  # not just the proxy's address
  option forwardfor
  # later down the track we'll be making the use
  # of cookies for various reasons. So we'll
  # enable support for this while we're here.
  cookie SERVERID insert nocache indirect
  # list the servers who are to be balanced
  # (just the one in the case of dev)
  server Webmachine1 127.0.0.1:8000</p>

<h6>##### Riak Configuration</h6>

<h1>We are yet to touch Riak so far, but given that</h1>

<h1>this post is going to cover the basics of</h1>

<h1>connectivity, we'll cover off the configuration</h1>

<h1>now so we don't have to do it later.</h1>

<p>frontend dbcluster
  # We'll be using protocol buffers to talk to
  # Riak, so we will change from the default mode
  # and use tcp instead
  mode tcp
  # we're only interested in allowing connections
  # from internal sources (so that we don't expose
  # ourselves to the web. so we shall only listen
  # on an internal interface on port 8080
  bind 127.0.0.1:8080
  # Default to the riak cluster configuration
  default_backend riaks</p>

<h1>Here is the magic bit which load balances across</h1>

<h1>our three instances of riak which are clustered</h1>

<h1>together</h1>

<p>backend riaks
  # again, make sure we specify tcp instead of
  # the default http mode
  mode tcp
  # use a standard round robin approach for load
  # balancing
  balance roundrobin
  # list the three servers as optional targets
  # for load balancing - these are what we set
  # up during Part 1. Add health-checking as
  # well so that when nodes go down, HAProxy
  # can remove them from the cluster
  server Riak1 127.0.0.1:8081 check
  server Riak2 127.0.0.1:8082 check
  server Riak3 127.0.0.1:8083 check
{% endcodeblock %}</p>

<p>In the configuration above the <code>backend riaks</code> section has three server nodes. Each one of them has the <code>check</code> option specified. This enables health-checking on the same address and port that the server instance is bound to. If you decided that you didn't want to do health-checking in this manner you easily enable health-checking over HTTP, as Riak has a built-in URI which can be used to validate the state of the node. Change the <code>backend riaks</code> section in the configuration to look like this:
{% codeblock lang:bash %}</p>

<h1>Here is the magic bit which load balances across</h1>

<h1>our three instances of riak which are clustered</h1>

<h1>together</h1>

<p>backend riaks
  # again, make sure we specify tcp instead of
  # the default http mode
  mode tcp
  # use a standard round robin approach for load
  # balancing
  balance roundrobin
  # enable HTTP health checking using the GET method
  # on the URI "/ping". This URI is part of Riak and
  # can be used to determine if the node is up.
  # We specify that we want to use the GET action, and
  # use the URI "/ping" - this is the RESTful health
  # check URI that comes as part of Riak.
  option httpchk GET /ping
  # list the three servers as optional targets
  # for load balancing - these are what we set
  # up during Part 1. Add health-checking as
  # well so that when nodes go down, HAProxy
  # can remove them from the cluster.</p>

<p>  # change the health-check address of the node to 127.0.0.0:8091
  # which is the REST interface for the first Riak node
  server Riak1 127.0.0.1:8081 check addr 127.0.0.1 port 8091</p>

<p>  # change the health-check address of the node to 127.0.0.0:8092
  # which is the REST interface for the second Riak node
  server Riak2 127.0.0.1:8082 check addr 127.0.0.1 port 8092</p>

<p>  # change the health-check address of the node to 127.0.0.0:8093
  # which is the REST interface for the third Riak node
  server Riak3 127.0.0.1:8083 check addr 127.0.0.1 port 8093
{% endcodeblock %}</p>

<p>To make sure this is functioning correctly, we need to open two consoles and change our working directory to our <code>csd</code> application (for those who have forgotten, <code>csd</code> is the application we're building - it was mentioned in <a href="/posts/webmachine-erlydtl-and-riak-part-1/" title="Wembachine, ErlyDTL and Riak - Part 1">Part 1</a>). In console 1:</p>

<pre><code>oj@nix ~/blog/csd $ sudo haproxy -f dev.haproxy.conf -d
Available polling systems :
     sepoll : pref=400,  test result OK
      epoll : pref=300,  test result OK
       poll : pref=200,  test result OK
     select : pref=150,  test result OK
Total: 4 (4 usable), will use sepoll.
Using sepoll() as the polling mechanism.
</code></pre>

<p>This indicates that HAProxy is up and running and waiting for connections. Let's get Webmachine fired up in console 2:</p>

<pre><code>oj@nix ~/blog/csd $ ./start.sh

    ... snip ...

=PROGRESS REPORT==== 4-Apr-2011::23:39:27 ===
         application: csd
          started_at: nonode@nohost
</code></pre>

<p>Now Webmachine is fired up with our application running. We should be able to hit our page, this time at <a href="http://localhost/" title="localhost">localhost</a>, and see exactly what we saw at the end of <a href="/posts/webmachine-erlydtl-and-riak-part-1/" title="Wembachine, ErlyDTL and Riak - Part 1">Part 1</a>.</p>

<p><img src="http://buffered.io/uploads/2010/09/haproxy-validation.png" /></p>

<h3>Verification of HAProxy configuration</h3>

<p>On the surface it appears that we haven't broken anything. We also need to make sure that any communication with Riak that we have down the track is also functioning. So let's validate that now.</p>

<p>First, we have to make sure that Riak is running. If you have followed <a href="/posts/webmachine-erlydtl-and-riak-part-1/" title="Wembachine, ErlyDTL and Riak - Part 1">Part 1</a> already and your Riak cluster is running then you're good to go. If not, please read <a href="/posts/webmachine-erlydtl-and-riak-part-1/" title="Wembachine, ErlyDTL and Riak - Part 1">Part 1</a> for information on how to install Riak and configure it to run as a cluster of 3 nodes.</p>

<p>Next, let's create 3 new connections and use the <a href="https://github.com/basho/riak-erlang-client/blob/master/src/riakc_pb_socket.erl#L181" title="riakc_pb_socket:get_server_info/1">get_server_info/1</a> function to find out which node we are connected to. To do this, we'll need to use an Erlang console which has all the Riak dependencies ready to go. It just so happens that when we fired up our Webmachine instance, we got an Erlang console for free. Simply hit the <code>enter</code> key and you'll be given a prompt. Notice that when we connect to Riak using the <a href="https://github.com/basho/riak-erlang-client/blob/master/src/riakc_pb_socket.erl#L97" title="riakc_pb_socket:start_link/2">start_link/2</a> function, we are passing in the IP address and port of the load-balanced cluster instead of one of the running Riak nodes:
{% codeblock lang:erlang %}
1> {ok, C1} = riakc_pb_socket:start_link("127.0.0.1", 8080).</p>

<p>=PROGRESS REPORT==== 4-Apr-2011::23:41:18 ===</p>

<pre><code>      supervisor: {local,inet_gethost_native_sup}
         started: [{pid,&lt;0.148.0&gt;},{mfa,{inet_gethost_native,init,[[]]}}]
</code></pre>

<p>=PROGRESS REPORT==== 4-Apr-2011::23:41:18 ===</p>

<pre><code>      supervisor: {local,kernel_safe_sup}
         started: [{pid,&lt;0.147.0&gt;},
                   {name,inet_gethost_native_sup},
                   {mfargs,{inet_gethost_native,start_link,[]}},
                   {restart_type,temporary},
                   {shutdown,1000},
                   {child_type,worker}]
</code></pre>

<p>{ok,&lt;0.146.0>}
2> riakc_pb_socket:get_server_info(C1).
{ok,[{node,&lt;&lt;"dev1@127.0.0.1">>},</p>

<pre><code> {server_version,&lt;&lt;"0.12.0"&gt;&gt;}]}
</code></pre>

<p>3> {ok, C2} = riakc_pb_socket:start_link("127.0.0.1", 8080).
{ok,&lt;0.151.0>}
4> riakc_pb_socket:get_server_info(C2).
{ok,[{node,&lt;&lt;"dev2@127.0.0.1">>},</p>

<pre><code> {server_version,&lt;&lt;"0.12.0"&gt;&gt;}]}
</code></pre>

<p>5> {ok, C3} = riakc_pb_socket:start_link("127.0.0.1", 8080).
{ok,&lt;0.154.0>}
6> riakc_pb_socket:get_server_info(C3).
{ok,[{node,&lt;&lt;"dev3@127.0.0.1">>},</p>

<pre><code> {server_version,&lt;&lt;"0.12.0"&gt;&gt;}]}
</code></pre>

<p>{% endcodeblock %}</p>

<p>So we can see that the load balancer has allocated three different connections, each to a different node in the cluster. This is a good sign. So let's kill off one of the nodes:</p>

<pre><code>oj@nix ~/blog/riak/dev $ dev2/bin/riak stop
ok
</code></pre>

<p>In a very short period of time, you should see output in the HAProxy console which looks something like this:</p>

<pre><code>[WARNING] 253/235636 (11824) : Server riaks/Riak2 is DOWN, reason: Layer4 connection problem, info: "Connection refused", check duration: 0ms.
</code></pre>

<p>The load balancer noticed that the node has died. Let's make sure it no longer attempts to allocate connections to <code>dev2</code>. Note that we call <a href="http://www.erlang.org/documentation/doc-5.2/doc/getting_started/getting_started.html" title="Getting started">f()</a> in our console before running the same script again, as this forces the shell to forget about any existing variable bindings:
{% codeblock lang:erlang %}
7> f().
ok
8> {ok, C1} = riakc_pb_socket:start_link("127.0.0.1", 8080).
{ok,&lt;0.1951.0>}
9> riakc_pb_socket:get_server_info(C1).
{ok,[{node,&lt;&lt;"dev1@127.0.0.1">>},</p>

<pre><code> {server_version,&lt;&lt;"0.12.0"&gt;&gt;}]}
</code></pre>

<p>10> {ok, C2} = riakc_pb_socket:start_link("127.0.0.1", 8080).
{ok,&lt;0.1954.0>}
11> riakc_pb_socket:get_server_info(C2).
{ok,[{node,&lt;&lt;"dev3@127.0.0.1">>},</p>

<pre><code> {server_version,&lt;&lt;"0.12.0"&gt;&gt;}]}
</code></pre>

<p>12> {ok, C3} = riakc_pb_socket:start_link("127.0.0.1", 8080).
{ok,&lt;0.1957.0>}
13> riakc_pb_socket:get_server_info(C3).
{ok,[{node,&lt;&lt;"dev1@127.0.0.1">>},</p>

<pre><code> {server_version,&lt;&lt;"0.12.0"&gt;&gt;}]}
</code></pre>

<p>{% endcodeblock %}</p>

<p>As we hoped, <code>dev2</code> is nowhere to be seen. Let's fire it up again:</p>

<pre><code>oj@nix ~/blog/riak/dev $ dev2/bin/riak start
</code></pre>

<p><strong>Note:</strong> It isn't necessary to tell the node to rejoin the cluster. This happens automatically. Thanks to Siculars (see comment thread) for pointing that out.</p>

<p>HAProxy's console will show you that it has re-established a connection to <code>dev2</code></p>

<pre><code>[WARNING] 253/235852 (11824) : Server riaks/Riak2 is UP, reason: Layer7 check passed, code: 200, info: "OK", check duration: 1ms.
</code></pre>

<p>As a final test, let's make sure we see that node get connections when we attempt to connect:
{% codeblock lang:erlang %}
14> f().
ok
15> {ok, C1} = riakc_pb_socket:start_link("127.0.0.1", 8080).
{ok,&lt;0.4203.0>}
16> riakc_pb_socket:get_server_info(C1).
{ok,[{node,&lt;&lt;"dev3@127.0.0.1">>},</p>

<pre><code> {server_version,&lt;&lt;"0.12.0"&gt;&gt;}]}
</code></pre>

<p>17> {ok, C2} = riakc_pb_socket:start_link("127.0.0.1", 8080).
{ok,&lt;0.4206.0>}
18> riakc_pb_socket:get_server_info(C2).
{ok,[{node,&lt;&lt;"dev1@127.0.0.1">>},</p>

<pre><code> {server_version,&lt;&lt;"0.12.0"&gt;&gt;}]}
</code></pre>

<p>19> {ok, C3} = riakc_pb_socket:start_link("127.0.0.1", 8080).
{ok,&lt;0.4209.0>}
20> riakc_pb_socket:get_server_info(C3).
{ok,[{node,&lt;&lt;"dev2@127.0.0.1">>},</p>

<pre><code> {server_version,&lt;&lt;"0.12.0"&gt;&gt;}]}
</code></pre>

<p>{% endcodeblock %}</p>

<h3>Wrapping up</h3>

<p>Excellent. Now that we've got our load-balancer set up in development, we're ready to dive into connecting to Riak from our <code>csd</code> application. That will be the topic for the next post in this series.</p>

<p>As always, comments and feedback are welcome and greatly appreciated. Suggestions on improvements and pointers on mistakes would be awesome. To anyone out there who has put HAProxy into production, we would love to hear your comments on your configuration!</p>

<p><strong>Note:</strong> The code for Part 2 (this post) can be found on <a href="https://github.com/OJ/csd/tree/Part2-20110403" title="Source Code for Part 2">Github</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Webmachine, ErlyDTL and Riak - Part 1]]></title>
    <link href="http://buffered.io/posts/webmachine-erlydtl-and-riak-part-1/"/>
    <updated>2010-09-01T23:29:00+10:00</updated>
    <id>http://buffered.io/posts/webmachine-erlydtl-and-riak-part-1</id>
    <content type="html"><![CDATA[<p><img src="http://buffered.io/uploads/2010/09/riak-logo.png" alt="Riak Logo" style="float:left;padding-right:5px;padding-bottom:5px;"/>It has been a long time coming, but the first post is finally here! This is the first in a series of post, as <a href="/posts/the-future-is-erlang/" title="The Future is Erlang">promised a while ago</a>, covering off web development using <a href="http://erlang.org/" title="Erlang">Erlang</a>. This post is the ubiquitous "get up and running" post, which aims to get your environment set up so that you can dive in to development. The next post will detail how to handle a basic end-to-end web request.</p>

<p><img src="http://buffered.io/uploads/2010/09/Erlang_logo.png" width="150" style="float:right;margin-left:5px;margin-bottom:5px;"/>First up, a few things we need to be aware of before we begin:</p>

<ol>
<li>The information in this post has only been verified on Linux (<a href="http://linuxmint.com/" title="Linux Mint">Mint</a> to be exact). It <em>should</em> work just fine on Mac OSX. I'm almost certain that it <em>won't</em> work on a Windows machine. So if you're a Windows developer, you'll have to wait for another post down the track which covers off how to get your environment ready to rock.</li>
<li>We'll be downloading, building and installing <a href="http://erlang.org/" title="Erlang">Erlang</a>, <a href="http://github.com/evanmiller/erlydtl" title="ErlyDTL">ErlyDTL</a>, <a href="http://www.basho.com/developers.html#Riak" title="Riak">Riak</a> and <a href="http://www.basho.com/developers.html#Webmachine" title="Webmachine">Webmachine</a>.</li>
<li><a href="http://www.basho.com/developers.html#Rebar" title="Rebar">Rebar</a> is the tool we'll be using to handle builds, but I won't be covering it in any depth.</li>
<li>You will need the latest versions of both <a href="http://hg-scm.com/" title="Mercurial">Mercurial</a> and <a href="http://git-scm.com/" title="Git">Git</a> so make sure they're downloaded and installed before you follow this article.</li>
<li>We'll be doing <em>some</em> interaction with Riak via <a href="http://curl.haxx.se/" title="cURL and libcurl">curl</a>, so make sure you have it downloaded and installed as well.</li>
<li>This is intended to be a step-by-step guide targeted at those who are very new to web development in Erlang. This may not be the most ideal set up, nor the best way of doing certain things. I am hoping that those people who are more experienced than I will be able to provide feedback and guidance in areas where I am lacking.</li>
<li>Over the course of this series I'll be attempting to build an Erlang version of the <a href="http://bitbucket.org/OJ/codesmackdown" title="Code Smackdown">Code Smackdown</a> site that I've been working on here and there with a <a href="http://secretgeek.net/" title="secretGeek">mate of mine</a>. You'll see that the sample application we're working on is called "csd" for obvious reasons.</li>
</ol>


<p>OK, let's get into it. First up, Erlang.</p>

<!--more-->


<h3>Installing Erlang R14B02</h3>

<p>Download and installation is fairly simple. Right now we're not worried about enabling all of the features of Erlang, such as interfacing with Java and providing support for GTK. So the boilerplate functionality is enough. Here are the steps to follow:</p>

<pre><code>oj@nix ~/blog $ wget http://erlang.org/download/otp_src_R14B02.tar.gz

  ... snip ...

oj@nix ~/blog $ tar -xzf otp_src_R14B02.tar.gz 
oj@nix ~/blog $ cd otp_src_R14B02/
oj@nix ~/blog/otp_src_R14B02 $ ./configure 

  ... snip ...

oj@nix ~/blog/otp_src_R14B02 $ make

  ... snip ...

oj@nix ~/blog/otp_src_R14B02 $ sudo make install

  ... snip ...
</code></pre>

<p>Done! Let's confirm that it has been set up correctly:</p>

<pre><code>oj@nix ~/blog $ erl
Erlang R14B02 (erts-5.8.3) [source] [64-bit] [smp:2:2] [rq:2] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.8.3  (abort with ^G)
1&gt; q().
ok
</code></pre>

<p>Excellent. Next let's get Riak going.</p>

<h3>Installing Riak 0.14</h3>

<p>Considering the power of the software you are about to set up, it is absolutely insane how easy it is to get it running. If any of you have tried to get <a href="http://couchdb.apache.org/" title="CouchDB">CouchDB</a> running you'll no doubt have experienced a few quirks and a bit of pain getting it rolling. Not so with Riak. As mentioned at the start of the article, make sure you have a recent version of <a href="http://hg-scm.com/" title="Mercurial">Mercurial</a> and <a href="http://git-scm.com/" title="Git">Git</a> installed.</p>

<pre><code>oj@nix ~/blog$ hg --version
Mercurial Distributed SCM (version 1.7.3)
(see http://mercurial.selenic.com for more information)

Copyright (C) 2005-2010 Matt Mackall and others
This is free software; see the source for copying conditions. There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

oj@nix ~/blog$ git --version
git version 1.7.3.5

oj@nix ~/blog $ git clone git://github.com/basho/riak
Cloning into riak...
remote: Counting objects: 10812, done.
remote: Compressing objects: 100% (3468/3468), done.
remote: Total 10812 (delta 7217), reused 10469 (delta 7020)
Receiving objects: 100% (10812/10812), 8.83 MiB | 729 KiB/s, done.
Resolving deltas: 100% (7217/7217), done.

oj@nix ~/blog $ cd riak
oj@nix ~/blog/riak $ make
./rebar get-deps
==&gt; rel (get-deps)
==&gt; riak (get-deps)
Pulling cluster_info from {git,"git://github.com/basho/cluster_info",
                               {branch,"master"}}
Cloning into cluster_info...
Pulling luwak from {git,"git://github.com/basho/luwak",{branch,"master"}}
Cloning into luwak...
Pulling riak_kv from {git,"git://github.com/basho/riak_kv",{branch,"master"}}
Cloning into riak_kv...
Pulling riak_err from {git,"git://github.com/basho/riak_err",
                           {branch,"master"}}
Cloning into riak_err...
==&gt; cluster_info (get-deps)
==&gt; riak_kv (get-deps)
Pulling riak_core from {git,"git://github.com/basho/riak_core",
                            {branch,"master"}}
Cloning into riak_core...
Pulling riakc from {git,"git://github.com/basho/riak-erlang-client",
                        {tag,"riakc-1.0.2"}}
Cloning into riakc...
Pulling luke from {git,"git://github.com/basho/luke",{tag,"luke-0.2.3"}}
Cloning into luke...
Pulling erlang_js from {git,"git://github.com/basho/erlang_js",
                            {tag,"erlang_js-0.5.0"}}
Cloning into erlang_js...
Pulling bitcask from {git,"git://github.com/basho/bitcask",{branch,"master"}}
Cloning into bitcask...
Pulling ebloom from {git,"git://github.com/basho/ebloom",{branch,"master"}}
Cloning into ebloom...
Pulling eper from {git,"git://github.com/dizzyd/eper.git",{branch,"master"}}
Cloning into eper...
==&gt; riak_core (get-deps)
Pulling protobuffs from {git,"git://github.com/basho/erlang_protobuffs",
                             {tag,"protobuffs-0.5.1"}}
Cloning into protobuffs...
Pulling basho_stats from {git,"git://github.com/basho/basho_stats","HEAD"}
Cloning into basho_stats...
Pulling riak_sysmon from {git,"git://github.com/basho/riak_sysmon",
                              {branch,"master"}}
Cloning into riak_sysmon...
Pulling webmachine from {git,"git://github.com/basho/webmachine",
                             {tag,"webmachine-1.8.0"}}
Cloning into webmachine...
==&gt; protobuffs (get-deps)
==&gt; basho_stats (get-deps)
==&gt; riak_sysmon (get-deps)
==&gt; webmachine (get-deps)
Pulling mochiweb from {git,"git://github.com/basho/mochiweb",
                           {tag,"mochiweb-1.7.1"}}
Cloning into mochiweb...
==&gt; mochiweb (get-deps)
==&gt; riakc (get-deps)
==&gt; luke (get-deps)
==&gt; erlang_js (get-deps)
==&gt; ebloom (get-deps)
==&gt; bitcask (get-deps)
==&gt; eper (get-deps)
==&gt; luwak (get-deps)
Pulling skerl from {git,"git://github.com/basho/skerl",{tag,"skerl-1.0.1"}}
Cloning into skerl...
==&gt; skerl (get-deps)
==&gt; riak_err (get-deps)
./rebar compile
==&gt; cluster_info (compile)
Compiled src/cluster_info_ex.erl


  ... snip ...
</code></pre>

<p>I snipped a lot of the make output for obvious reasons. Let's build a few development nodes of Riak and cluster them together as indicated in the <a href="https://wiki.basho.com/display/RIAK/The+Riak+Fast+Track" title="Riak Fast Track">Riak Fast Track</a>:</p>

<pre><code>oj@nix ~/blog/riak $ make devrel
mkdir -p dev
(cd rel &amp;&amp; ../rebar generate target_dir=../dev/dev1 overlay_vars=vars/dev1_vars.config)
==&gt; rel (generate)
mkdir -p dev
(cd rel &amp;&amp; ../rebar generate target_dir=../dev/dev2 overlay_vars=vars/dev2_vars.config)
==&gt; rel (generate)
mkdir -p dev
(cd rel &amp;&amp; ../rebar generate target_dir=../dev/dev3 overlay_vars=vars/dev3_vars.config)
==&gt; rel (generate)

oj@nix ~/blog/riak $ cd dev
oj@nix ~/blog/riak/dev $ dev1/bin/riak start
oj@nix ~/blog/riak/dev $ dev2/bin/riak start
oj@nix ~/blog/riak/dev $ dev3/bin/riak start
oj@nix ~/blog/riak/dev $ dev2/bin/riak-admin join dev1
Sent join request to dev1

oj@nix ~/blog/riak/dev $ dev3/bin/riak-admin join dev1
Sent join request to dev1

oj@nix ~/blog/riak/dev $ curl -H "Accept: text/plain" http://127.0.0.1:8091/stats
{
  ... snip ...

  "nodename": "dev1@127.0.0.1",
    "connected_nodes": [
    "dev2@127.0.0.1",
    "dev3@127.0.0.1"
  ],

  ... snip ...

  "ring_members": [
    "dev1@127.0.0.1",
    "dev2@127.0.0.1",
    "dev3@127.0.0.1"
  ],
  "ring_num_partitions": 64,
  "ring_ownership": "[{'dev3@127.0.0.1',21},{'dev2@127.0.0.1',21},{'dev1@127.0.0.1',22}]",

  ... snip ...
}
</code></pre>

<p>As we can see from the curl output, we now have a 3-node Riak cluster up and running. Those three nodes have the following traits:</p>

<table border="1">
  <thead>
    <tr>
      <th>Name</th>
      <th>Protobuf Port</th>
      <th>HTTP Port</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>dev1@127.0.0.1</td>
      <td>8081</td>
      <td>8091</td>
    </tr>
    <tr>
      <td>dev2@127.0.0.1</td>
      <td>8082</td>
      <td>8092</td>
    </tr>
    <tr>
      <td>dev3@127.0.0.1</td>
      <td>8083</td>
      <td>8093</td>
    </tr>
  </tbody>
</table>


<p>We can talk to any of these nodes and they will replicate their data to the other nodes. Nifty! Now that we have a Riak cluster running for development, let's get Webmachine ready.</p>

<h3>Installing Webmachine 0.8</h3>

<p>Again, the process is very simple:</p>

<pre><code>oj@nix ~/blog $ git clone git://github.com/basho/webmachine
loning into webmachine...
remote: Counting objects: 1183, done.
remote: Compressing objects: 100% (484/484), done.
remote: Total 1183 (delta 735), reused 1063 (delta 668)
Receiving objects: 100% (1183/1183), 1.17 MiB | 294 KiB/s, done.
Resolving deltas: 100% (735/735), done.

oj@nix ~/blog $ cd webmachine/
oj@nix ~/blog/webmachine $ make
==&gt; webmachine (get-deps)
Pulling mochiweb from {git,"git://github.com/mochi/mochiweb",{tag,"1.5.1"}}
Cloning into mochiweb...
==&gt; mochiweb (get-deps)
==&gt; mochiweb (compile)
Compiled src/mochiglobal.erl
Compiled src/mochiweb_sup.erl

  ... snip ...
</code></pre>

<p>As you can see, Webmachine sits on top of the <a href="http://github.com/mochi/mochiweb" title="Mochiweb">Mochiweb</a> web server.</p>

<p>To create our own application which sits on top of Webmachine, we can utilise the <code>new_webmachine.sh</code> script. So let's do that to create our Code Smackdown (csd) site:</p>

<pre><code>oj@nix ~/blog/webmachine $ scripts/new_webmachine.sh
usage: new_webmachine.sh name [destdir]
oj@nix ~/blog/webmachine $ scripts/new_webmachine.sh csd ..
==&gt; priv (create)
Writing /home/oj/blog/csd/README
Writing /home/oj/blog/csd/Makefile
Writing /home/oj/blog/csd/rebar.config
Writing /home/oj/blog/csd/rebar
Writing /home/oj/blog/csd/start.sh
Writing /home/oj/blog/csd/src/csd.app.src
Writing /home/oj/blog/csd/src/csd.erl
Writing /home/oj/blog/csd/src/csd_app.erl
Writing /home/oj/blog/csd/src/csd_sup.erl
Writing /home/oj/blog/csd/src/csd_resource.erl
Writing /home/oj/blog/csd/priv/dispatch.conf
</code></pre>

<p>Webmachine generates a fully functional website out of the box. So we should be able to build it, fire it up and see it in action:</p>

<pre><code>oj@nix ~/blog/webmachine $ cd ../csd
oj@nix ~/blog/csd $ make
==&gt; csd (get-deps)
Pulling webmachine from {git,"git://github.com/basho/webmachine","HEAD"}
Cloning into webmachine...
==&gt; webmachine (get-deps)
Pulling mochiweb from {git,"git://github.com/mochi/mochiweb",{tag,"1.5.1"}}
Cloning into mochiweb...
==&gt; mochiweb (get-deps)
==&gt; mochiweb (compile)
Compiled src/mochiglobal.erl

  ... snip ...

oj@nix ~/blog/csd $ ./start.sh
Erlang R14B02 (erts-5.8.3) [source] [64-bit] [smp:2:2] [rq:2] [async-threads:0] [hipe] [kernel-poll:false]

  ... snip ...

PROGRESS REPORT==== 3-Apr-2011::22:38:36 ===
          supervisor: {local,csd_sup}
             started: [{pid,&lt;0.76.0&gt;},
                       {name,webmachine_mochiweb},
                       {mfargs,
                           {webmachine_mochiweb,start,
                               [[{ip,"0.0.0.0"},
                                 {port,8000},
                                 {log_dir,"priv/log"},
                                 {dispatch,[{[],csd_resource,[]}]}]]}},
                       {restart_type,permanent},
                       {shutdown,5000},
                       {child_type,worker}]

=PROGRESS REPORT==== 3-Apr-2011::22:38:36 ===
         application: csd
          started_at: nonode@nohost
</code></pre>

<p>The application is now up and running. As you can see from the output, our csd application has been fired up and is listening on port 8000. Let's fire it up in a web browser to see if it works.</p>

<p><img src="http://buffered.io/uploads/2010/09/wm_default.png"/></p>

<p>It's alive! We're almost done. Before we finish up, let's get set up our build to include some dependencies.</p>

<h3>Adding ErlyDTL and Riak Client Dependencies</h3>

<p>Rebar makes this bit a walk in the park (thanks <a href="http://dizzyd.com/" title="Gradual Epiphany">Dave</a>, you rock!). Just make sure you stop your Webmachine node before continuing by typing <code>q().</code> into your Erlang console.</p>

<p>The <code>rebar.config</code> file is what drives rebar's dependency mechanism. We need to open this file and add the entries we need to include in our application. Webmachine's <code>start.sh</code> script by default includes all of the dependencies on start up, so after modifying the configuration, we don't have to do anything else (other than use the library of course).</p>

<p>Open up <code>rebar.config</code> in your <a href="http://www.vim.org/" title="VIM">favourite editor</a>, it should look something like this:</p>

<p>{% codeblock rebar.config lang:erlang %}
%%-<em>- mode: erlang -</em>-</p>

<p>{deps, [{webmachine, "1.8.*", {git, "git://github.com/basho/webmachine", "HEAD"}}]}.
{% endcodeblock %}</p>

<p>Edit the file so that it includes both ErlyDTL and the Riak Client:</p>

<p>{% codeblock rebar.config lang:erlang %}
%%-<em>- mode: erlang -</em>-
{deps,
  [</p>

<pre><code>{webmachine, "1.8.*", {git, "git://github.com/basho/webmachine", "HEAD"}},
{riakc, ".*", {git, "git://github.com/basho/riak-erlang-client", "HEAD"}},
{erlydtl, "0.6.1", {git, "git://github.com/OJ/erlydtl.git", "HEAD"}}
</code></pre>

<p>  ]
}.
{% endcodeblock %}</p>

<p>You'll notice that the <code>erlydtl</code> reference points at my own fork of the ErlyDTL project. This is because I have made it compile cleanly with rebar so that any dependent projects are also able to be build with rebar. Feel free to use your own fork if you like, but mine is there if you can't be bothered :)</p>

<p>Save the file and build!</p>

<pre><code>oj@nix ~/blog/csd $ make
==&gt; mochiweb (get-deps)
==&gt; webmachine (get-deps)
==&gt; csd (get-deps)
Pulling riakc from {git,"git://github.com/basho/riak-erlang-client","HEAD"}
Cloning into riakc...
Pulling erlydtl from {git,"git://github.com/OJ/erlydtl.git","HEAD"}
Cloning into erlydtl...
==&gt; riakc (get-deps)
Pulling protobuffs from {git,"git://github.com/basho/erlang_protobuffs",
                             {tag,"protobuffs-0.5.1"}}
Cloning into protobuffs...
==&gt; protobuffs (get-deps)
==&gt; erlydtl (get-deps)
==&gt; mochiweb (compile)
==&gt; webmachine (compile)
==&gt; protobuffs (compile)
Compiled src/pokemon_pb.erl
Compiled src/protobuffs_parser.erl

  ... snip ...
</code></pre>

<p>Dependencies sorted. For the final part of this blog post, we'll include a basic ErlyDTL template and use it to render the page so we can see how it works.</p>

<h3>Rendering an ErlyDTL Template</h3>

<p>Rebar has built-in support for the compilation of ErlyDTL templates. It can be configured to behave how you want it to, but out of the box it...</p>

<ul>
<li>... looks for <code>*.dtl</code> files in the <code>./templates</code> folder</li>
<li>... compiles each of the found templates into a module called <code>filename_dtl</code> (eg. <code>base.dtl</code> becomes the module base_dtl)</li>
<li>... puts the module beam files into the <code>ebin</code> directory</li>
</ul>


<p>Very handy. Let's create a very simple template by creating a <code>templates</code> folder, and editing a new file in that folder called <code>sample.dtl</code></p>

<p>{% codeblock templates/sample.dtl lang:html %}
<html><body>Hello from inside ErlyDTL. You passed in {{ param }}.</body></html>
{% endcodeblock %}</p>

<p>Then open up <code>src/csd_resource.erl</code> and search for the <code>to_html()</code> function. It should look like this:</p>

<p>{% codeblock src/csd_resource.erl lang:erlang %}
to_html(ReqData, State) -></p>

<pre><code>{"&lt;html&gt;&lt;body&gt;Hello, new world&lt;/body&gt;&lt;/html&gt;", ReqData, State}.
</code></pre>

<p>{% endcodeblock %}</p>

<p>Modify it to look like this:</p>

<p>{% codeblock src/csd_resource.erl lang:erlang %}
to_html(ReqData, State) -></p>

<pre><code>{ok, Content} = sample_dtl:render([{param, "Slartibartfast"}]),
{Content, ReqData, State}.
</code></pre>

<p>{% endcodeblock %}</p>

<p>For now, don't worry about the content of this file. I will cover this off in a future post.</p>

<p>In the past, we had to manually modify <code>ebin/csd.app</code> to include the template that we've just created. Thankfully, <code>rebar</code> has been updated so that it generates the <code>ebin/csd.app</code> file from the <code>src/csd.app.src</code> file automatically when the application is built. <code>rebar</code> adds the required modules from the <code>src</code> folder <em>and</em> includes the templates from the <code>templates</code> folder. Therefore, with our template and module ready to go, all we need to do is build and run:</p>

<pre><code>oj@nix ~/blog/csd $ make
==&gt; mochiweb (get-deps)
==&gt; webmachine (get-deps)
==&gt; protobuffs (get-deps)
==&gt; riakc (get-deps)
==&gt; erlydtl (get-deps)
==&gt; csd (get-deps)
==&gt; mochiweb (compile)
==&gt; webmachine (compile)
==&gt; protobuffs (compile)
==&gt; riakc (compile)
==&gt; erlydtl (compile)
==&gt; csd (compile)
Compiled src/csd_resource.erl
Compiled templates/sample.dtl

oj@nix ~/blog/csd $ ./start.sh 
Erlang R14B02 (erts-5.8.3) [source] [64-bit] [smp:2:2] [rq:2] [async-threads:0] [hipe] [kernel-poll:false]

  ... snip ...

** Found 0 name clashes in code paths 

  ... snip ...

=PROGRESS REPORT==== 3-Apr-2011::22:54:50 ===
         application: csd
          started_at: nonode@nohost
</code></pre>

<p>Notice how ErlyDTL outputs some information to indicate that no template names have clashed with any other modules.</p>

<p>The application is now running, let's see what it looks like:</p>

<p><img src="http://buffered.io/uploads/2010/09/wm_erlydtl.png"/></p>

<h3>The End</h3>

<p>We now have a working environment in which to do our development. In the next post, I'll cover some of the basics required to get Webmachine talking to Riak via <a href="http://en.wikipedia.org/wiki/Protocol_Buffers" title="Protocol Buffers">Protocol Buffers</a>.</p>

<p>Feedback and criticism welcome!</p>

<p><strong>Note:</strong> The code for Part 1 (this post) can be found on <a href="https://github.com/OJ/csd/tree/Part1-20110403" title="Source Code for Part 1">Github</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Future is Erlang]]></title>
    <link href="http://buffered.io/posts/the-future-is-erlang/"/>
    <updated>2009-10-31T20:28:00+10:00</updated>
    <id>http://buffered.io/posts/the-future-is-erlang</id>
    <content type="html"><![CDATA[<p><img src="http://buffered.io/uploads/2009/10/erlang.png" alt="erlang" title="erlang" style="float:left;margin-right:5px;margin-bottom:5px;" />For quite a while I've been using my spare cycles to chew over a problem. This problem is not one that hasn't been solved before, but one that I feel can be solved in a much better way. From the bit of research that I've done, I can see at least three areas which can be improved on dramatically. So I've decided, after a long period of deliberation, to go ahead and build my solution and release it to the world as a service!</p>

<p>I know, this kind of thing happens thousands of times a day. Some arbitrary geek decided to build the next killer app and expects to make a crapload of cash out of it. While that would be nice, the ultimate goal isn't the cash. The goal for me is to build something that gets used, and for me to begin to master an area of technology that I've had a quiet passion for for a long period of time now.</p>

<p>My plan is simple. While learning the technologies that I will be using I'll be building another application and blogging about it so that all of you can learn with me. Meanwhile, I shall use my learnings to build this other application at the same time.</p>

<p>The final result should be a series of posts which help other people learn the technology stack, give better coverage and visibility to languages and technologies that a lot of the geek world doesn't know about (and really should!), and for me to carve myself a bit of a niche here on the East coast of Ozland. I am hoping to be able to consult my services out to other businesses as a result.</p>

<p>For those that are interested in following along, here is the full tech stack and toolset that I'll be using:</p>

<ul>
<li><a href="http://erlang.org/" title="Erlang">Erlang</a> - A fantastic cross-platform functional programming language that has some amazing features.</li>
<li><a href="http://bitbucket.org/justin/webmachine/" title="Webmachine HTTP toolkit">Webmachine</a> - A HTTP toolkit which sits on top of <a href="http://code.google.com/p/mochiweb/" title="Mochiweb">Mochiweb</a> that makes it easy to build well-behaved HTTP applications.</li>
<li><a href="http://nitrogenproject.com/" title="Nitrogen Framework">Nitrogen</a> - An Erlang-based framework that makes it easy to build websites.</li>
<li><a href="http://riak.basho.com/" title="Riak">Riak</a> or <a href="http://couchdb.apache.org/" title="CouchDB">CouchDB</a> - Both of these amazing pieces of tech are potential candidates for the back-end storage. I'm not yet sure which one I'll go with.</li>
<li><a href="http://jquery.com/" title="jQuery">jQuery</a> - A great JavaScript library for the front-end.</li>
<li><a href="http://vim.org/" title="VIM text editor">VIM</a> - My favourite text editor :)</li>
<li><a href="http://www.xubuntu.org/" title="Xubuntu">Xubuntu</a> - Ubuntu <a href="http://ubuntu.com/" title="Ubuntu 9.10">Karmic Koala</a> with <a href="http://www.xfce.org/" title="XFCE">XFCE</a> as the window manager.</li>
<li><a href="http://mercurial-scm.org/" title="Mercurial SCM">Mercurial</a> - My favourite version control system.</li>
<li><a href="http://trac.edgewall.org/" title="The Trac Project">Trac</a> - A project tracking tool.</li>
<li><a href="http://www.virtualbox.org/" title="VirtualBox">VirtualBox</a> - My choice for virtualisation. I tend to run Windows 7 as my primary OS, so most of my dev will be in a VM. When I get my desktop machine back up and running (with all three monitors!) it'll most likely multiboot Win 7 and Xubuntu.
<li><a href="http://wave.google.com/" title="Google Wave">Google Wave</a> - I'll be using this for communications with some really switched on people in the Erlang community who have kindly offered to help me with questions and whatnot specific to some of the areas of tech I've mentioned above.</li>
</ul>


<p>During the course of my blogging/learning I'll be focussing on Webmachine, Riak/CouchDB, Erlang and Nitrogen. All the other tools will probably get mentioned along the way, but the primary goal is to focus on these things.</p>

<p>I'm really excited! I'm currently in the process of documenting my goals and the design for the main application. Once that's done, I'll get started with the fun stuff. I've got a lot to do and it should be a fun ride. I hope you enjoy following along!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Websites are Hard to Build]]></title>
    <link href="http://buffered.io/posts/websites-are-hard-to-build/"/>
    <updated>2008-11-26T21:08:00+10:00</updated>
    <id>http://buffered.io/posts/websites-are-hard-to-build</id>
    <content type="html"><![CDATA[<p><img src="http://buffered.io/uploads/2008/11/elope-harlequin-jester.jpg" alt="Uninformed client" title="Uninformed client" style="float: left; margin-right: 5px; margin-bottom: 5px;" /><blockquote><p>"It's just a small site, how hard can it be?"</p>

<p>"I thought you could do it for me as a favour. It's not a complicated site."</p>

<p>"This would take me an afternoon, but I don't have time, can you do it for me?"</p></blockquote>Have you ever heard these comments before? Have you heard ones that are similar? I've been hearing them a lot in the last few weeks and it's starting to get to me.</p>

<p>I have just had a chat with a mate who is also suffering this pain, and that conversation is what inspired me to write this, the first random rant in a while.</p>

<!--more-->


<p>Let me start by saying that <em>building software is <strong>hard</strong></em>. Building <em>quality</em> software is <strong>harder</strong>. I've been in the industry for 10 years now, and I can say with a certain level of confidence (and perhaps a little bit of authority) that it's harder than most people think -- particularly business users, clients and lots of family and friends.</p>

<p>Let me follow that on by saying that websites are software (no way!). That puts them in the "hard" basket. Every site, even if it's a static page with some simple content, comes with its own set of challenges -- and those challenges are rarely understood by anyone who hasn't experienced the pain of building software.</p>

<p>The point of this post it to give a little bit of exposure to some of these issues. I hope that this post gets read by those people who have plans to have some sort of software built but haven't really got a clue what's involved.</p>

<h2>Requirement Issues</h2>


<p>Let's be fair ... you don't know what you want. You <em>think</em> you do, but you really don't. You have an idea for something that will either make your life easier or "be really cool", but as far as actually <strong>thinking</strong> about how it would function ... ? You haven't done that at all.</p>

<p>Here lies the first of the big stumbling blocks. You want a website, because "everyone has a website these days" for almost everything. Started a new business? You must have a website! Released an album? You must have a website! Had a child? You must have a website! Never had a website? You must have a website!</p>

<p>Before you dive headlong into the quest to find the person to build the site for you, have a good long think about what it is you want that site to be. What is its purpose? What content is required? Will it be dynamic? Will it be static? Will it be data-driven and require a <a href="http://en.wikipedia.org/wiki/Content_management_system" title="Content Management System">Content Management System</a>? Do you want other people to submit content? Do you want to have the facility available for readers to add their own comments? Will it be product driven and need the ability for people to buy stuff directly from the site? Do you need it to work on all browsers? Does it require access via a mobile phone or hand-held gadget?</p>

<p>These questions need to be answered well before any design is even contemplated, let alone structure and technical architecture. Do yourself and your site development team a favour. Think long and hard about what you want, and while you're doing that, ponder what possible issues you might face. The more issues you think of now, the cheaper it will be to build the site that fits your needs. Not just that, but you'll reduce the "scope on a rope" which results in the blowout of timelines and budgets.</p>

<h2>Design Issues</h2>


<p>We're coming to the end of 2008 and yet people still don't realise that development is <strong>not the same as design</strong>. Ask yourself the question: if design is part of development, then why do people make a living out of website design? The answer is simple: It's a big job, and it's very hard to do it right. I'm a developer, and I feel that there are very few (if any) areas of development that I couldn't do well in (yes, I'm arrogant ;)), but I can tell you this for certain: I am <strong>not a designer</strong>. <a href="http://shiftperception.com/blog/" title="Shiftperception">Dan</a> will no doubt appreciate that comment ;)</p>

<p>It's true, I am not a designer. I can not design websites. I can do the technical desing, the architecture and the implementation. I can not do the design. Creating the right design for a website isn't an easy thing to do. I can tell you when people get it right, and I can tell you when people get it wrong. I can't tell you why :)</p>

<p>So, again, do yourself a favour. Get a proper web designer with a great portfolio of projects and go through the ideas you have with them. They will end up providing you an interface which makes sense for what you're trying to do. Do not fall into the trap of assuming that this part of the process isn't important. Yes, up front the cost most appear higher, but in the long run you will not regret it.</p>

<h2>Technical Issues</h2>


<p>Stumbling block number 3 is the lack of understanding of the technical issues. It's no surprise though, considering that most people wanting sites are not technical in nature. While it's fine for a client to not have (or want) an understanding of the technical issues, it's certainly <em>not</em> fine for them to ignore the fact that they even exist. Sticking your head in the sand and saying things like "well you'll figure it out" or "isn't that what I'm paying you for" doesn't really cut the mustard, particularly when you haven't thought about what you want in the first place.</p>

<p>When building websites there are all kinds of technical hurdles to leap over. To name a few...</p>

<ul>
<li><strong>Platform</strong> - I think most of the non-techie readers will have no clue of what I mean here. The platform is what the site runs on. That is, the operating system, the runtime, the software that supports it, etc.</li>
<li><strong>Cross-browser compatibility</strong> - The biggest issue in any Internet-facing website is cross-browser issues. Not all browsers were made equally. Each and every one has its own set of quirks, and the people responsible for building the interface to the site need to cater for all these quirks. If they don't, then they may alienate a subset of potential readers which would do damage to the site's potential traffic and income. <strong>DO NOT</strong> underestimate how painful this can be. Yes, there are tools out there which apparently take care of these issues for you, but let me tell you that most of the time they fail too. Be prepared for a great deal of work to go into making your site look and behave on the same on a variety of browsers. As a small side-note, some browsers actually behave differently on, say, Windows compared to how they would on, say, Mac OSX.</li>
<li><strong>Secure payments</strong> - Sounds easy right? "I just want the ability for people to enter credit card details and pay for stuff." Unfortunately it isn't that simple. You have all kinds of issues to worry about if you want that to happen directly in your site. You have to set up <a href="http://en.wikipedia.org/wiki/Transport_Layer_Security" title="Transport layer security">SSL</a>, you have to arrange for a proper payment portal to site behind your site and handle the requests. You need to make sure your site is set up in such a way that any malicious users can not buy stuff without paying, nor have honest users' information compromised and shared. There are other options, such as <a href="http://www.paypal.com/" title="PayPal">PayPal</a> and <a href="https://payments.amazon.com/sdui/sdui/index.htm" title="Amazon Payments">Amazon</a>, but these facilities operate externally and won't appear "incorporated" in the site.</li>
<li><strong>Accessibility</strong> - You've done well if you already know what this is. In short, it refers to your sites ability to be read by people who are visually impaired who use devices such as <a href="http://en.wikipedia.org/wiki/Screen_reader" title="Screen reader">screen readers</a>. If you want your site to be fully accessible, then expect a great deal more effort to be involved. Your site needs to be structured in a special way and it needs to be <strong>fully</strong> compliant with a markup standard (such as <a href="http://www.w3.org/TR/html4/sgml/loosedtd.html" title="HTML 4.0">HTML 4.0 Transitional</a>).</li>
<li><strong>Hosting</strong> - This issue comes with a stack of other issues that most people don't even think about (sometimes even developers!). Do you have your own host? Do you have a shared host? Dedicated host? Do you need it in your own country? Do you need Windows or Linux? Do you need email facilities? Do you need SSL? Do you need a <a href="http://en.wikipedia.org/wiki/Content_Delivery_Network" title="Content delivery network">CDN</a>? Choosing a location for your site is affected by so many things. For example, if you're looking for a fully secure site which keeps track of user details and sensitive information (such as credit cards) then a shared hosting solution is an <em>EPIC FAIL</em>. In case the reason isn't obvious I'll tell you. If you use a shared host, then the entire machine is only as secure as the weakest account. If another site, owned by someone else, is compromised then the attacker owns the box which contains YOUR sites as well.</li>
<li><strong>Database</strong> - This isn't just about which one to use. It's about how to use it. Databases are underestimated and often misunderstood. It's <em>very</em> easy to do databases wrong. This is a real kicker for those applications that are very database heavy. In particular, applications which require complex relationships and/or deep searching capabilities. If your application relies on an insanely speedy, distributed database or is search-heavy, you had best get yourself a DB guru ... and be prepared to pay for them! A recent example with some interested details was recently posted on <a href="http://blog.stackoverflow.com/2008/11/sql-2008-full-text-search-problems/" title="SQL 2008 Full Text Search Problems">StackOverflow</a>, go have a read!</li>
<li><strong>Traffic</strong> - If you're aiming to build a site that isn't going to be used often or doesn't have a great deal of content, then this might not be so much of an issue. But if you have a site that is going to be bombarded with traffic, don't expect your first cut of your system to, er, cut it. I once heard a semi-famous man say "<a href="http://www.codinghorror.com/blog/archives/000957.html" title="Everything is fast for small n">Everything is fast for small <em>n</em>"</a>, and he's dead right. In development and testing, your app will probably fly. But under load, with thousands of people hitting it at the same time, it may just keel over and die. Be prepared to face this problem in the development stage.</li>
<li><strong>Maintainability</strong> - I left this one last because it's a little verbose and somewhat random. So many things can affect the maintainability of the site. The main problem here though is that in general, the idea of maintenance after a site has been developed is far from anyone's thoughts. Maintenance is where you'll spend most of your cash long term. Minimising the potential issues during development really is key to making a site which isn't going to cost the earth to maintain or enhance. The most common cause of highly unmaintainable websites is "Little Johnny" (LJ). LJ is the bloke that someone knows through a friend of a friend, or through the family. He's the guy who "knows stuff about computers". Of course, that means that he can &lt;sarcasm&gt;build commercial websites that are flexible, secure, fast, extendible, easy to maintain and that WORK&lt;/sarcasm&gt;. In all seriousness, you might know someone who knows something about computers, but if you're serious about your site, then get someone who knows what they're doing. You'll pay more in the long run for someone who doesn't. Either that, or take one of your employees, and put them through a course so that they can learn how it's done. To sum up, if you want to reduce the cost of maintenance there is a lot of work involved, and your developers need to know what they're doing. Be prepared for a lot of work in this area.</li>
</ul>


<h2>Testing Issues</h2>


<p>Testing? What's that?</p>

<p>It's frightening that even in Enterprise software, testing is generally an afterthought. Recently I was fortunate enough to be part of a team where testing was a huge part of the development process. It was <em>really</em> good and the result was a seriously higher quality application.</p>

<p>Developers do not know how to test their own code properly. Sure, they can write unit tests, and they do some form of manual functional testing on a daily basis while they're building the software. This is <strong>not</strong> the same as having a full test plan and suite of tests to verify the quality of the application.</p>

<p>Do yourself a favour, spend some of your budget and get some testers in. They will put your application/site through its paces instead of your users!</p>

<h2>Deployment Issues</h2>


<p>Once you've worked with a development team, you'll become very familiar with the following phrase:<blockquote><p>It works on my machine.</p></blockquote>It's something that you'll hear constantly :)</p>

<p>The point here is that it is very common for things to work in the development environment, but end up breaking when deployed to a production environment. Deployment is another often overlooked area of the process. When it <em>is</em> considered, it's underestimated.</p>

<p>Be careful. Here be dragons. Before you get stuck, speak to someone who <a href="http://johnmcfadyen.spaces.live.com/" title="John Mcfadyen's Windows Installer blog">knows what they're doing</a>.</p>

<h2>Support Issues</h2>


<p>So you've managed to ship your application. It's online, it's deployed and it's running. But something goes wrong. The site breaks every now and then. Users are having issues with the payment portal. People using Firefox on Mac OSX can't sign in. Reports are coming back with incorrect values.</p>

<p>Do you have a plan in place to handle these requests? Do you have a <a href="http://en.wikipedia.org/wiki/Bugtracker" title="Bug tracker">bug tracking system</a>? Do you have a support team ready to handle requests? Have you kept any of the development team on board to help you with the support issues?</p>

<p>Generally, the answer to all of these questions is: no. My advice would be to make it a yes. Put a plan in place to help you with the teething issues once you've gone live. Trust me, there <em>will</em> be issues.</p>

<h2>Conclusion</h2>


<p>I hope that the target audience have a little more visibility of the issues that are faced when building websites (and software in general). I hope that they learn from it and take some of the advice and do proper preparation before undertaking a development project.</p>

<p>Finally, I really do hope that it stops some of you from coming out with the comments listed at the start of this post :)</p>

<p>As always, feedback and comments are welcomed and appreciated. Cheers!</p>
]]></content>
  </entry>
  
</feed>
