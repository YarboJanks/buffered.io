<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Series | OJ's rants]]></title>
  <link href="http://buffered.io/categories/series/atom.xml" rel="self"/>
  <link href="http://buffered.io/"/>
  <updated>2012-09-29T21:14:19+10:00</updated>
  <id>http://buffered.io/</id>
  <author>
    <name><![CDATA[OJ Reeves]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sorting Things Out]]></title>
    <link href="http://buffered.io/posts/sorting-things-out/"/>
    <updated>2008-08-13T12:23:00+10:00</updated>
    <id>http://buffered.io/posts/sorting-things-out</id>
    <content type="html"><![CDATA[<p>It's time to recap a topic that is, or should be, close to the heart of every developer. A topic that is often overlooked or glossed over, rarely fully understood and not often discussed. Yet this topic is hugely important.</p>

<p>That topic is <strong>Sorting</strong>.</p>

<!--more-->


<p><img src="http://buffered.io/uploads/2008/08/sorting-beans.jpg" alt="Sorting" title="Sorting" width="168" height="224" style="float: right; margin-left: 5px; margin-bottom: 5px;" />On the surface it appears to be so simple. Just arrange some stuff in a certain order. What could be easier?</p>

<p>Unfortunately the implementations of various methods of sorting can be anything but easy. Determining <em>which</em> algorithm to choose can be difficult enough given that some lend themselves to sorting certain data types better than others do.</p>

<p>As a result, I've decided to start writing a series on the different well-known (and perhaps not-so-well-known) sorting algorithms. For each algorithm, my goal will be to:</p>

<ol>
<li>Paint a very clear picture of how it functions. I aim to do this via pictures and discussion. If I get time, I will aim to provide an animated visualiser of the algorithm (though at the moment this might be a tough ask given time constraints).</li>
<li>Explain the <a href="http://en.wikipedia.org/wiki/Big_O_notation" title="Big O">order of complexity/Big-O notation</a> so that it's clear just how expensive it is to use, along with details of best and worst cases.</li>
<li>Give examples of data sets where the algorithm fits well, and examples of where it doesn't.</li>
<li>Explain if and how the given algorithm can be used in a multhithreaded environment.</li>
<li>Demonstrate errors that are found frequently in various implementations (if there are any), and show how to resolve/avoid them.</li>
</ol>


<p>By the end of the series, I hope that you (and I) will have a really solid understanding of the Sorting world.</p>

<p>To start off with, I'll be covering the age-old <a href="http://buffered.io/posts/sorting-algorithms-the-bubble-sort/" title="Sorting Algorithms: The Bubble Sort">Bubble Sort</a>. I'm choosing this because it's very simple, and is an easy target for me to get going.</p>

<p>As always, comments and feedback will be greatly appreciated. I'm hoping that I'll learn more from this exercise than you guys will.</p>
]]></content>
  </entry>
  
</feed>
