<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithms | OJ's rants]]></title>
  <link href="http://buffered.io/categories/algorithms/atom.xml" rel="self"/>
  <link href="http://buffered.io/"/>
  <updated>2012-02-15T21:21:25+10:00</updated>
  <id>http://buffered.io/</id>
  <author>
    <name><![CDATA[OJ Reeves]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Data Crunching in Haskell]]></title>
    <link href="http://buffered.io/posts/data-crunching-in-haskell/"/>
    <updated>2009-06-25T00:00:00+10:00</updated>
    <id>http://buffered.io/posts/data-crunching-in-haskell</id>
    <content type="html"><![CDATA[<p>A few days ago I was having a chat to a <a href="http://shiftperception.com/blog" title="Shifty">friend of mine</a> about a little data parsing problem. He had the need to parse a multi-dimensional array to pull out some values. That array was guaranteed to be square, but not necessarily in contiguous memory. He needed to parse each "column" of the array, calculate a total, and then determine the biggest and smallest of those totals.</p>

<p>A sample of the data might look something like this:</p>

<pre><code>data = ({150,200,45,57,95,2,45,32,15,10,5,2,2,4},
         12,20,45,37,10,5,2,2,10,95,2,45,32,7},
         32,15,10,5,2,23,24,15,20,45,57,95,0,45})
</code></pre>

<p>So the first step would be to add 150, 12 and 32 and store the value. Then 200, 20 and 15, and store the value. Do this for all of the columns, then get a maximum and a minimum.</p>

<!--more-->


<p>This little algorithm was going to be part of his project, and hence needed to be implemented in <a href="http://www.adobe.com/devnet/actionscript/articles/actionscript3_overview.html" title="ActionScript 3.0">AS3</a>. So I picked his brains about the AS3 syntax, because I have absolutely no clue given that I've never worked with any version of ActionScript in the past.</p>

<p>Together, we came up with the following solution:</p>

<pre><code>var columnTotal:Number;
var biggest:Number;
var smallest:Number;
biggest = smallest = sum(vData, 0);

for(var i = 1; i &lt; _scope.period_mcs.length; ++i)
{
  columnTotal = sum(vData, i);
  biggest = Math.max(biggest, columnTotal);
  smallest = Math.min(smallest, columnTotal);
}

// helper function 
function sum(var data:Array, var index:Integer):Number
{
  var total:Number = 0;
  for(int i = 0; i &lt; data.length; ++i)
  {
    total += data[i][index];
  }
  return total;
}
</code></pre>

<p>Does it work? Yes, it sure does. Is it optimal? Yes, and no :) I was lazy and used the Math.max and Math.min functions instead of doing the obvious...</p>

<pre><code>if(biggest &lt; columnTotal) biggest = columnTotal;
</code></pre>

<p>So if we did that, to reduce the need for function calls and unnecessary assignments, we end up with this:</p>

<pre><code>var columnTotal:Number;
var biggest:Number;
var smallest:Number;
biggest = smallest = sum(vData, 0);

for(var i = 1; i &lt; _scope.period_mcs.length; ++i)
{
  columnTotal = sum(vData, i);
  if(biggest &lt; columnTotal)
  {
    biggest = columnTotal;
  }
  else if(smallest &gt; columnTotal)
  {
    smallest = columnTotal;
  }
}

// helper function 
function sum(var data:Array, var index:Integer):Number
{
  var total:Number = 0;
  for(int i = 0; i &lt; data.length; ++i)
  {
    total += data[i][index];
  }
  return total;
}
</code></pre>

<p>I can't see many ways to improve on this without going overboard with optimisation. Any AS3 guru's are more than welcome to prove me wrong!</p>

<p>So after thinking about this in an imperative language, I couldn't help but have a look at what the functional version might look like. Of course, my current chosen Functional toy is <a href="http://haskell.org/" title="Haskell">Haskell</a> and so I fired up <a href="http://vim.org/" title="VIM">VIM</a> and <a href="http://www.haskell.org/ghc/" title="GHC">GHCI</a> and had a bit of a play.</p>

<p>First, I put the data into Haskell's list format:</p>

<p>{% codeblock lang:haskell %}
vals = [[150,200,45,57,95,2,45,32,15,10,5,2,2,4],</p>

<pre><code>    [12,20,45,37,10,5,2,2,10,95,2,45,32,7],
    [32,15,10,5,2,23,24,15,20,45,57,95,0,45]]
</code></pre>

<p>{% endcodeblock %}</p>

<p>That was easy enough. The next step was to break the problem down so that I could use some of the built in functions of Haskell's <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html" title="Prelude">Prelude</a> libraries. My thought processes were:</p>

<ol>
<li>Summing the column of the array could be done using <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:sum" title="sum">sum</a>, but I'd need to change the list so that rows become columns, and vice-versa.</li>
<li>To switch rows and columns, I could use the <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v:transpose" title="Data.List.transpose">transpose</a> function.</li>
<li>Then all I'd need to do is use <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:maximum" title="maximum">maximum</a> and <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:minimum" title="minimum">minimum</a> to get the right values out.</li>
</ol>


<p>Being a bit of a primitive Haskeller, my first pass was something like this:
{% codeblock lang:haskell %}
extremes n = (b, s)
  where</p>

<pre><code>l = map sum $ transpose n
b = maximum l
s = minimum l
</code></pre>

<p>{% endcodeblock %}</p>

<p>The function <em>extremes</em> is the function which takes the data (list of lists) and spits out a tuple of <em>(max, min)</em>.</p>

<p>Before the end of the conversation with my designer colleague in arms, I pinged him my version of the solution in Haskell and needless to say he was a little surprised as how concise it was. I was sure to point out that there is no doubt a better way of representing this solution with regards to speed and conciseness.</p>

<p>The first thing that I thought could be improved would be using a custom <a href="http://www.haskell.org/haskellwiki/Fold" title="Fold">fold</a> to get the max and min while parsing the transposed list. This would allow us to calculate the values in a single pass and hence be a little better with regards to performance. That would obviously sacrifice a little bit of the conciseness we're looking for.</p>

<p>When the conversation ended, I jumped onto IRC and spoke to some more seasoned Haskellers. The first suggested improvement that popped out of that chat was to use <a href="http://www.haskell.org/arrows/" title="Arrows">arrows</a> to remove the need for the where clause. That solution looks like this:
{% codeblock lang:haskell %}
extremes = (maximum &amp;&amp;&amp; minimum) . map sum . transpose
{% endcodeblock %}</p>

<p>Nifty :) Of all the other options, this proved to be the most readable and concise, though not the best performing.</p>

<p>The next most notable solution included the fold which calculated the min and max in a single parse, not a double parse:
{% codeblock lang:haskell %}
extremes = foldl1 ((a, b) -> max a *** min b) . join zip . map sum . transpose
{% endcodeblock %}</p>

<p>Folds really are fantastic aren't they. Again we're using arrows here to do a bit of heavy lifting and that keeps things looking a little nicer.</p>

<p>So after this little session, my designer friend was aware of how easy it can be to crunch certain types of data using a functional language, like Haskell. It made me think again about how it'd be nice to just be able to plug in whichever language we wanted whenever we felt it would do the job better than whatever the current tool is.</p>

<p>So how would you improve it? :)</p>

<!--adsense-->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sorting Algorithms: The Gnome Sort]]></title>
    <link href="http://buffered.io/posts/sorting-algorithms-the-gnome-sort/"/>
    <updated>2008-10-16T20:58:00+10:00</updated>
    <id>http://buffered.io/posts/sorting-algorithms-the-gnome-sort</id>
    <content type="html"><![CDATA[<p><img src="http://buffered.io/uploads/2008/10/gnome.jpg" alt="Gnome Sort" title="Gnome Sort" width="240" style="float: right; margin-left: 5px; margin-bottom: 5px;"/>After a bit of down time for personal reasons, here is the fourth post in the series on <a href="http://buffered.io/category/sorting/" title="Sorting @ OJ's rants">sorting</a> algorithms. This time round we're taking a good look at the <strong>Gnome Sort</strong>.</p>

<p>People often do a double-take when hearing the term "Gnome Sort" because it's not that common. The <strong>Gnome Sort</strong> is extremely simple, and is very similar to the principle behind the <strong>Insertion Sort</strong> (which we'll be covering soon).</p>

<p>The Gnome Sort is yet another <em>comparison</em> and <em>exchange</em> sort which has elements that are similar to the <a href="http://buffered.io/posts/sorting-algorithms-the-bubble-sort/" title="Sorting Algorithms: The Bubble Sort">Bubble Sort</a>. If you haven't read up on the Bubble Sort, be sure to do that before reading this article as it may help with your understanding.</p>

<!--more-->


<p>Let's get straight into it!</p>

<h2>Common Terms</h2>


<ul>
<li><em>Data set</em> - the array or list of items that is to be sorted.</li>
<li><em>n</em> - the number of elements in the <em>data set</em>.</li>
<li><em>Bubble</em> - perform a <strong>Bubble Sort-like</strong> shuffle of an item in a given direction.</li>
</ul>




<h2>The Algorithm</h2>


<p>The first principle to bear in mind when doing a <strong>Gnome Sort</strong> is that as the algorithm progresses, all items to the left of the <em>current</em> item are always in order. Each iteration of the algorithm moves the current item to the correct spot with respect to the previously sorted items.</p>

<p>The first part of the algorithm looks at the first two items in the <em>data set</em> and swaps them around if they are in the wrong order. Then, for each iteration thereafter, the next item is <em>bubbled backwards</em> towards to head of the list until a value is encountered which is less than the current item (or the head of the list is reached). At this point, the current item is left alone, and the sort continues from the next item.</p>

<h2>The Example</h2>




<p>As per usual we will use the same initial <em>data set</em> that we used for the Bubble Sort and Cocktail Sort to aid in highlighting the differences.</p>

<p>The initial set looks like this:</p>

<p><span class="eg">33 98 74 13 55 20 77 45 64 83</span></p>

<p>The first step is to compare the firs two values:</p>

<p><span class="eg"><b>33</b> <b>98</b> 74 13 55 20 77 45 64 83</span></p>

<p>Given that they are in the correct order we leave this two values alone. We can say that two items in the <em>data set</em> are <strong>in order</strong>.</p>

<p>Next we look at the item immediately after the <strong>in order</strong> items and compare that to the last sorted item:</p>

<p><span class="eg">33 <b>98</b> <b>74</b> 13 55 20 77 45 64 83</span></p>

<p>We can see that these two are not in the correct order, so we swap them:</p>

<p><span class="eg">33 <i>74</i> <i>98</i> 13 55 20 77 45 64 83</span></p>

<p>Given that we had to swap the values in the previous step, we can't assume that the current item is in the right location with respect to the other <strong>in order</strong> items, and hence we need to continue to work backwards. We compare the current item to the preceeding item in the <em>data set</em>:</p>

<p><span class="eg"><b>33</b> <b>74</b> 98 13 55 20 77 45 64 83</span></p>

<p>These two values are in the correct order, so we can now stop this iteration. At this point, the first three items in the set are sorted with respect to each other. Next, we move to the fourth item, and compare that with the last of the <strong>in order</strong> items:</p>

<p><span class="eg">33 74 <b>98</b> <b>13</b> 55 20 77 45 64 83</span></p>

<p>They're out of order, so we swap them:</p>

<p><span class="eg">33 74 <i>13</i> <i>98</i> 55 20 77 45 64 83</span></p>

<p>... and we keep <em>bubbling backwards</em> until we reach either a value that is smaller or the head of the list:</p>

<p><span class="eg">33 <b>74</b> <b>13</b> 98 55 20 77 45 64 83</span>
<span class="eg">33 <i>13</i> <i>74</i> 98 55 20 77 45 64 83</span>
<span class="eg"><b>33</b> <b>13</b> 74 98 55 20 77 45 64 83</span>
<span class="eg"><i>13</i> <i>33</i> 74 98 55 20 77 45 64 83</span></p>

<p>Here we can see that 13 was the smallest number, so it was bubbled all the way to the head of the list. We then move on to the next iteration where we again compare the next item with the head of the list, and again <em>bubble backwards</em> until we reach the correct location. Here is a summary of the steps for the next iteration:</p>

<p><span class="eg">13 33 74 <b>98</b> <b>55</b> 20 77 45 64 83</span>
<span class="eg">13 33 74 <i>55</i> <i>98</i> 20 77 45 64 83</span>
<span class="eg">13 33 <b>74</b> <b>55</b> 98 20 77 45 64 83</span>
<span class="eg">13 33 <i>55</i> <i>74</i> 98 20 77 45 64 83</span>
<span class="eg">13 <b>33</b> <b>55</b> 74 98 20 77 45 64 83</span></p>

<p>55 is now in the correct spot with regards to the other pre-sorted items, so we move onto the next item. At this point it should be fairly obvious what's going on, so I shall show a summary for the rest of the example:</p>

<p><span class="eg">13 33 55 74 <b>98</b> <b>20</b> 77 45 64 83</span>
<span class="eg">13 33 55 74 <i>20</i> <i>98</i> 77 45 64 83</span>
<span class="eg">13 33 55 <b>74</b> <b>20</b> 98 77 45 64 83</span>
<span class="eg">13 33 55 <i>20</i> <i>74</i> 98 77 45 64 83</span>
<span class="eg">13 33 <b>55</b> <b>20</b> 74 98 77 45 64 83</span>
<span class="eg">13 33 <i>20</i> <i>55</i> 74 98 77 45 64 83</span>
<span class="eg">13 <b>33</b> <b>20</b> 55 74 98 77 45 64 83</span>
<span class="eg">13 <i>20</i> <i>33</i> 55 74 98 77 45 64 83</span>
<span class="eg"><b>13</b> <b>20</b> 33 55 74 98 77 45 64 83</span>
<span class="eg">13 20 33 55 74 <b>98</b> <b>77</b> 45 64 83</span>
<span class="eg">13 20 33 55 74 <i>77</i> <i>98</i> 45 64 83</span>
<span class="eg">13 20 33 55 <b>74</b> <b>77</b> 98 45 64 83</span>
<span class="eg">13 20 33 55 74 77 <b>98</b> <b>45</b> 64 83</span>
<span class="eg">13 20 33 55 74 77 <i>45</i> <i>98</i> 64 83</span>
<span class="eg">13 20 33 55 74 <b>77</b> <b>45</b> 98 64 83</span>
<span class="eg">13 20 33 55 74 <i>45</i> <i>77</i> 98 64 83</span>
<span class="eg">13 20 33 55 <b>74</b> <b>45</b> 77 98 64 83</span>
<span class="eg">13 20 33 55 <i>45</i> <i>74</i> 77 98 64 83</span>
<span class="eg">13 20 33 <b>55</b> <b>45</b> 74 77 98 64 83</span>
<span class="eg">13 20 33 <i>45</i> <i>55</i> 74 77 98 64 83</span>
<span class="eg">13 20 <b>33</b> <b>45</b> 55 74 77 98 64 83</span>
<span class="eg">13 20 33 45 55 74 77 <b>98</b> <b>64</b> 83</span>
<span class="eg">13 20 33 45 55 74 77 <i>64</i> <i>98</i> 83</span>
<span class="eg">13 20 33 45 55 74 <b>77</b> <b>64</b> 98 83</span>
<span class="eg">13 20 33 45 55 74 <i>64</i> <i>77</i> 98 83</span>
<span class="eg">13 20 33 45 55 <b>74</b> <b>64</b> 77 98 83</span>
<span class="eg">13 20 33 45 55 <i>64</i> <i>74</i> 77 98 83</span>
<span class="eg">13 20 33 45 <b>55</b> <b>64</b> 74 77 98 83</span>
<span class="eg">13 20 33 45 55 64 74 77 <b>98</b> <b>83</b></span>
<span class="eg">13 20 33 45 55 64 74 77 <i>83</i> <i>98</i></span>
<span class="eg">13 20 33 45 55 64 74 <b>77</b> <b>83</b> 98</span>
<span class="eg"><u>13</u> <u>20</u> <u>33</u> <u>45</u> <u>55</u> <u>64</u> <u>74</u> <u>77</u> <u>83</u> <u>98</u></span></p>

<p>Note that we do not know for sure that an item is in the correct location until the entire set has been sorted.</p>

<h2>The Implementation</h2>


<p>Here is a sample implementation written in <a href="http://en.wikipedia.org/wiki/C_Sharp" title="C Sharp">C#</a>. It is heavily commented in the hope that it will aid in understanding how the algorithm works:</p>

<p>{% codeblock lang:csharp %}
/// <summary>
/// Example implementation of the Gnome Sort algorithm.
/// </summary>
/// <param name="dataSet">Array of items to be sorted.</param>
static void GnomeSort(int[] dataSet)
{</p>

<pre><code>// start at the second item
int i = 1;

// keep track of the 'next' item so we
// can jump to it when the current iteration
// is finished.
int j = 2;

// loop until we reach the end of the data set
while (i &lt; dataSet.Length)
{
    // swap if required
    if (dataSet[i - 1] &gt; dataSet[i])
    {
        Swap(dataSet, i - 1, i);

        // move backwards through the sorted items
        // until we find the rightful spot.
        --i;

        // stop at the head of the list
        if (i == 0)
        {
            // jump to the next item in the set
            i = j++;
        }
    }
    else
    {
        // jump to the next item in the set
        i = j++;
    }
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<h2>The Complexity</h2>


<p>This is not a very efficient algorithm. It's time and space complexity are exactly that of the <a href="http://buffered.io/posts/sorting-algorithms-the-bubble-sort/" title="Sorting Algorithms: The Bubble Sort">Bubble Sort</a>. That is, the time complexity is O(n<sup>2</sup>), and space complexity for in-place sorting is O(1).</p>

<p><a name="GnomeSortBitBucket"></a></p>

<h2>Other Implementations</h2>


<p>I'm slowly gathering a collection of implementations of all the sorting algorithms, including the ones listed above, that I'm covering in this series and posting them up on <a href="http://www.bitbucket.org/OJ/sorting/overview/" title="Sorting @ OJ's BitBucket">BitBucket</a>. The Gnome Sort implementations can be found <a href=http://www.bitbucket.org/OJ/sorting/src/3f2af8511799/04-GnomeSort/" title="GnomeSort @ OJ's BitBucket">here</a>.</p>

<p><em>Note: You'll need <a href="http://www.selenic.com/mercurial/" title="Mercurial">Mercurial</a> if you want to pull directly from the repository, otherwise you'll have to copy and paste from the web.</em></p>

<h2>References and Other Information</h2>


<ol>
<li><a href="http://en.wikipedia.org/wiki/Gnome_sort" title="Gnome sort">Wikipedia - Gnome sort</a></li>
</ol>


<p>Next up, we'll be looking at the first of the mind-bending algorithms: the <strong>Quick Sort</strong>.</p>

<h2>Disclaimer</h2>


<p>I'm no expert, nor an authority. The post above is based on my experience and a bit of research. If you find something wrong with anything I've said please let me know. Comments and feedback are greatly appreciated.</p>

<p><em>Note: For those reading this article in an RSS reader, you may find the colours do not appear in the examples properly. For some reason the feed is stripping out some of the formatting. I will do my best to fix this up soon.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sorting Algorithms: The Comb Sort]]></title>
    <link href="http://buffered.io/posts/sorting-algorithms-the-comb-sort/"/>
    <updated>2008-09-14T20:26:00+10:00</updated>
    <id>http://buffered.io/posts/sorting-algorithms-the-comb-sort</id>
    <content type="html"><![CDATA[<p><img src="http://buffered.io/uploads/2008/09/combsort.jpg" alt="Comb Sort" title="Comb Sort" width="150" style="float: left; margin-right: 5px; margin-bottom: 5px;" />Welcome to this, the third post in the series on <a href="http://buffered.io/category/sorting/" title="Sorting @ OJ's rants">sorting</a> algorithms. Next up, we're going to cover the <strong>Comb Sort</strong>.</p>

<p>Like the <a href="http://buffered.io/posts/sorting-algorithms-the-cocktail-sort/" title="Sorting Algorithms: The Cocktail Sort">Cocktail Sort</a>, the Comb Sort isn't particularly well known. Most people manage to make their way through tertiary studies without ever hearing of it. This post is designed to change that!</p>

<p>The Comb Sort is another <em>comparison</em> and <em>exchange</em> sort which builds on the idea of the <a href="http://buffered.io/posts/sorting-algorithms-the-bubble-sort/" title="Sorting Algorithms: The Bubble Sort">Bubble Sort</a> and adds a potential optimisation or two.</p>

<p>Make sure you read the articles on the <a href="http://buffered.io/posts/sorting-algorithms-the-bubble-sort/" title="Sorting Algorithms: The Bubble Sort">Bubble Sort</a> and the <a href="http://buffered.io/posts/sorting-algorithms-the-cocktail-sort/" title="Sorting Algorithms: The Cocktail Sort">Cocktail Sort</a> before you read this article. Doing so will make it much easier to understand.</p>

<!--more-->


<p>Right, enough with the introductions, let's break it down!</p>

<h2>Common Terms</h2>


<ul>
<li><em>Data set</em> - the array or list of items that is to be sorted.</li>
<li><em>n</em> - the number of elements in the <em>data set</em>.</li>
<li><em>Turtle</em> - a name given to small numbers that appear towards the end of a <em>data set</em>. When used in a <strong>Bubble Sort</strong>, small numbers at the end of the set take a very long time to get to the front of the list, and hence are called <em>turtles</em> because of the lack of speed.</li>
<li><em>Hare</em> - a name given to large numbers that appear towards the start of a <em>data set</em>. When used in a <strong>Bubble Sort</strong>, large numbers move to the end of the set very quickly, and hence are called <em>hares</em> due to their high speed.</li>
<li><em>Killing the turtles</em> - a phrase that implies quickly moving <em>turtles</em> to the front of the <em>data set</em>.
<li><em>Gap</em> - the size of the gap between areas of the <em>data set</em> that are being sorted during a given iteration of the sort.
<li><em>Shrink Factor</em> - a factor which is applied to the <em>gap</em> prior to each iteration to reduce its size.
</ul>




<h2>A Bit of Background Information</h2>


<p>The <strong>Comb Sort</strong>, along with the <strong>Cocktail Sort</strong>, was developed as an improvement to the <strong>Bubble Sort</strong> using the idea of <em>killing the turtles</em>. <em>Turtles</em> drastically reduce the efficiency of the <strong>Bubble Sort</strong> and hence are an obvious place to attempt optimisation.</p>

<p>The Bubble Sort algorithm always compares values that are adjacent to each other in the <em>data set</em>. The Comb Sort improves on this by adding a <em>gap</em> which allows non-adjacent numbers to be compared. After each iteration, the <em>gap</em> is reduced by a <em>shrink factor</em> until it reaches the value of <strong>1</strong>. Hence, at the very end, the Comb Sort behaves exactly like the Bubble Sort.</p>

<p>One interesting thing to note about this algorithm is that it's almost as fast as a Quick Sort!</p>

<h2>The Algorithm</h2>


<p>Each iteration of the algorithm consists of three stages:<ol><li>Calculation of the <em>gap</em> value.</li><li>Iterating over the <em>data set</em> comparing each item with the item that is <em>"gap"</em> elements further down the list and swapping them if required.</li><li>Checking to see if the gap value has reached one and no swaps have occurred. If so, then the set has been sorted.</li></ol></p>

<h3>1. Calculating the "gap"</h3>


<p>The <em>gap</em>, which is essentially an offset used when comparing elements, is something that changes for each iteration. The value needs to change in a uniform manner in such a way as to provide optimum comparisons during the sorting phases.</p>

<p>Stephen Lacey and Richard Box, who popularised the algorithm, suggested that in each iteration the <em>gap</em> should be reduced by a factor of approximately 1.3 (see the <a href="http://en.wikipedia.org/wiki/Comb_sort" title="Comb sort @ Wikipedia">wikipedia article</a> for more information). Hence, calculation of the <em>gap</em> is as simple as starting with the size of the <em>data set</em> and dividing by a <em>shrink factor</em> of 1.3 each iteration.</p>

<h3>2. Iterating and Swapping</h3>


<p>This phase is the same as the Bubble Sort. The only difference in the Comb Sort is that the items which are compared are <em>i</em> and <em>i + gap</em> as opposed to <em>i</em> and <em>i + 1</em>.</p>

<p>For each iteration, we start at the beginning of the <em>data set</em> and loop until <em>i + gap</em> is greater-than or equal to the size of the <em>data </em>. For each sub-iteration in this loop, we compare <em>i</em> and <em>i + gap</em> and swap the values if required.</p>

<p>At this point the <em>gap is recalculated</em> and we go again.</p>

<h3>3. Terminating the Loop</h3>


<p>When the <em>gap</em> value reaches one, we know that we're now behaving the same as the Bubble Sort algorithm (since we're comparing <em>i</em> and <em>i + 1</em>), so we know that if we don't perform any swaps during the iteration then the set must be sorted.</p>

<h2>The Example</h2>




<p>As per usual we will use the same initial <em>data set</em> that we used for the Bubble Sort and Cocktail Sort to aid in highlighting the differences.</p>

<p>The initial set looks like this:</p>

<p><span class="eg">33 98 74 13 55 20 77 45 64 83</span></p>

<p>We start by setting our <em>gap</em> value to 10, which is the size of the set. We then shrink the gap by the <em>shrink factor</em>, 1.3, which results in the value of 7 (when rounded down).</p>

<p>The first iteration starts at the beginning of the set, comparing the 1st item with the item that is "<em>gap</em>" elements further up the set (the 8th item). These two items are shown in red:</p>

<p><span class="eg"><b>33</b> 98 74 13 55 20 77 <b>45</b> 64 83</span></p>

<p>33 is less than 45, so no swap is required. We then move to the 2nd item, and compare that item with the 9th item:</p>

<p><span class="eg">33 <b>98</b> 74 13 55 20 77 45 <b>64</b> 83</span></p>

<p>We perform a swap at this point because 98 is bigger than 64. The swap is shown in blue:</p>

<p><span class="eg">33 <i>64</i> 74 13 55 20 77 45 <i>98</i> 83</span></p>

<p>We then move on to compare the 3rd and 10th elements:</p>

<p><span class="eg">33 64 <b>74</b> 13 55 20 77 45 98 <b>83</b></span></p>

<p>Again, no swap is required here as the numbers are in the right order.</p>

<p>At this point we have completed our first iteration as we've reached the end of the set. Given that the <em>gap</em> value is not 1, we know we still have more iterations to go. So we need to recalculate our <em>gap</em> value by dividing it again by the <em>shrink factor</em>, resulting in a value of 5 (after rounding down).</p>

<p>We then start another iteration from the beginning of the set, using the <em>gap</em> value of 5 as the offset. We start with the 1st and 6th items:</p>

<p><span class="eg"><b>33</b> 64 74 13 55 <b>20</b> 77 45 98 83</span></p>

<p>Given 33 is bigger than 20, we swap:</p>

<p><span class="eg"><i>20</i> 64 74 13 55 <i>33</i> 77 45 98 83</span></p>

<p>Then we compare the 2nd and 7th items:</p>

<p><span class="eg">20 <b>64</b> 74 13 55 33 <b>77</b> 45 98 83</span></p>

<p>No swap required, move to the 3rd and 8th items:</p>

<p><span class="eg">20 64 <b>74</b> 13 55 33 77 <b>45</b> 98 83</span></p>

<p>Perform the swap since 74 is bigger than 45:</p>

<p><span class="eg">20 64 <i>45</i> 13 55 33 77 <i>74</i> 98 83</span></p>

<p>We then compare the 4th and 9th items:</p>

<p><span class="eg">20 64 45 <b>13</b> 55 33 77 74 <b>98</b> 83</span></p>

<p>No swap required, compare the 5th and 10th items:</p>

<p><span class="eg">20 64 45 13 <b>55</b> 33 77 74 98 <b>83</b></span></p>

<p>Again, no swap required. We've hit the end of this next iteration, and since <em>gap</em> doesn't equal 1, we recalculate (resulting in the value of 3) and go again.</p>

<p>This time I'll just show a summary of the steps:</p>

<p><span class="eg"><b>20</b> 64 45 <b>13</b> 55 33 77 74 98 83</span>
<span class="eg"><i>13</i> 64 45 <i>20</i> 55 33 77 74 98 83</span>
<span class="eg">13 <b>64</b> 45 20 <b>55</b> 33 77 74 98 83</span>
<span class="eg">13 <i>55</i> 45 20 <i>64</i> 33 77 74 98 83</span>
<span class="eg">13 55 <b>45</b> 20 64 <b>33</b> 77 74 98 83</span>
<span class="eg">13 55 <i>33</i> 20 64 <i>45</i> 77 74 98 83</span>
<span class="eg">13 55 33 <b>20</b> 64 45 <b>77</b> 74 98 83</span>
<span class="eg">13 55 33 20 <b>64</b> 45 77 <b>74</b> 98 83</span>
<span class="eg">13 55 33 20 64 <b>45</b> 77 74 <b>98</b> 83</span>
<span class="eg">13 55 33 20 64 45 <b>77</b> 74 98 <b>83</b></span></p>

<p>Again, we iterate the value of <em>gap</em>, which becomes 2, and we go again:</p>

<p><span class="eg"><b>13</b> 55 <b>33</b> 20 64 45 77 74 98 83</span>
<span class="eg">13 <b>55</b> 33 <b>20</b> 64 45 77 74 98 83</span>
<span class="eg">13 <i>20</i> 33 <i>55</i> 64 45 77 74 98 83</span>
<span class="eg">13 20 <b>33</b> 55 <b>64</b> 45 77 74 98 83</span>
<span class="eg">13 20 33 <b>55</b> 64 <b>45</b> 77 74 98 83</span>
<span class="eg">13 20 33 <i>45</i> 64 <i>55</i> 77 74 98 83</span>
<span class="eg">13 20 33 45 <b>64</b> 55 <b>77</b> 74 98 83</span>
<span class="eg">13 20 33 45 64 <b>55</b> 77 <b>74</b> 98 83</span>
<span class="eg">13 20 33 45 64 55 <b>77</b> 74 <b>98</b> 83</span>
<span class="eg">13 20 33 45 64 55 77 <b>74</b> 98 <b>83</b></span></p>

<p>Finally, we reduce the value of <em>gap</em> one more time, resulting in the value of 1. We're finally at the <strong>Bubble Sort</strong> stage, and hence the last iteration looks like this:</p>

<p><span class="eg"><b>13</b> <b>20</b> 33 45 64 55 77 74 98 83</span>
<span class="eg">13 <b>20</b> <b>33</b> 45 64 55 77 74 98 83</span>
<span class="eg">13 20 <b>33</b> <b>45</b> 64 55 77 74 98 83</span>
<span class="eg">13 20 33 <b>45</b> <b>64</b> 55 77 74 98 83</span>
<span class="eg">13 20 33 45 <b>64</b> <b>55</b> 77 74 98 83</span>
<span class="eg">13 20 33 45 <i>55</i> <i>64</i> 77 74 98 83</span>
<span class="eg">13 20 33 45 55 <b>64</b> <b>77</b> 74 98 83</span>
<span class="eg">13 20 33 45 55 64 <b>77</b> <b>74</b> 98 83</span>
<span class="eg">13 20 33 45 55 64 <i>74</i> <i>77</i> 98 83</span>
<span class="eg">13 20 33 45 55 64 74 77 <b>98</b> <b>83</b></span>
<span class="eg">13 20 33 45 55 64 74 77 <i>83</i> <i>98</i></span>
<span class="eg"><u>13</u> <u>20</u> <u>33</u> <u>45</u> <u>55</u> <u>64</u> <u>74</u> <u>77</u> <u>83</u> <u>98</u></span></p>

<p>At this point we know, due to observation, that the list is sorted. Unfortunately, the algorithm is yet to know. It looks at the value of <em>gap</em> and sees that it is set to 1, but during the last iteration there were swaps -- so the code will iterate again.</p>

<p>At the end of this iteration, given that there were no swaps, it will know that the list is sorted and the code will terminate.</p>

<h2>The Implementation</h2>


<p>Here is a sample implementation written in <a href="http://en.wikipedia.org/wiki/C_Sharp" title="C Sharp">C#</a>. It is heavily commented in the hope that it will aid in understanding how the algorithm works:</p>

<p>{% codeblock lang:csharp %}
/// <summary>
/// The implementation of the standard comb sort algorithm which sorts
/// an array of integers.
/// </summary>
/// <param name="dataSet">Reference to the dataset that is to be soroted.</param>
static void CombSort(int[] dataSet)
{</p>

<pre><code>// start by using the length/size of the set as the gap.
int gap = dataSet.Length;

// loop indefinately.
while (true)
{
    // update the gap value so that it shrinks
    // towards 1.
    if (gap &gt; 1)
    {
        gap = (int)((double)gap / SHRINK_FACTOR);
    }

    // do the comb sort with the current gap
    bool swapped = false;
    for (int i = 0; i + gap &lt; dataSet.Length; ++i)
    {
        if (dataSet[i] &gt; dataSet[i + gap])
        {
            Swap(dataSet, i, i + gap);
            swapped = true;
        }
    }

    // if we're down to a gap of 1, and we haven't swapped
    // anything, then we're sorted.
    if (gap == 1 &amp;&amp; !swapped)
    {
        break;
    }
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<h2>The Complexity</h2>


<p>This is quite surprising. Despite being based on the idea of a <a href="http://buffered.io/posts/sorting-algorithms-the-bubble-sort/" title="Sorting Algorithms: The Bubble Sort">Bubble Sort</a> the time complexity is just O(n log n), and space complexity for in-place sorting is O(1). Amazing for such a simple sorting algorithm!</p>

<h2>A Note on Performance</h2>


<p>What I'm about to say is almost a direct rip-off of Wikipedia ;) But at least I'm being honest!</p>

<p>When you use a <em>shrink factor</em> of 1.3, as recommended, it turns out that there are only 3 ways for the gap sizes to reduce to 1. They are:</p>

<p><span class="eg">1. - 9, 6, 4, 3, 2, 1</span>
<span class="eg">2. - 10, 7, 5, 3, 2, 1</span>
<span class="eg">3. - 11, 8, 6, 4, 3, 2, 1</span></p>

<p>According to Wikipedia, it turns out that the 3rd option is the only one which manages to <em>kill all turtles</em> before the <em>gap</em> becomes 1. I haven't been able to find anything that backs this up though.</p>

<p>Assuming that this is true, we can create a modified version of the <strong>Comb Sort</strong> which has this extra little check:
{% codeblock lang:csharp %}
if(gap == 9 || gap == 10)
{</p>

<pre><code>gap = 11;
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>This is a little hack which makes sure that we get the third option before we reduce the <em>gap</em> to 1. Of course, this would only have an effect on sets of data which have more than 11 elements.</p>

<p><a name="CombSortBitBucket"></a></p>

<h2>Other Implementations</h2>


<p>I'm slowly gathering a collection of implementations of all the sorting algorithms, including the ones listed above, that I'm covering in this series and posting them up on <a href="http://www.bitbucket.org/OJ/sorting/overview/" title="Sorting @ OJ's BitBucket">BitBucket</a>. The Comb Sort implementations can be found <a href="http://www.bitbucket.org/OJ/sorting/src/b26f42ecdbe0/03-CombSort/" title="CombSort @ OJ's BitBucket">here</a>.</p>

<p><em>Note: You'll need <a href="http://www.selenic.com/mercurial/" title="Mercurial">Mercurial</a> if you want to pull directly from the repository, otherwise you'll have to copy and paste from the web.</em></p>

<h2>References and Other Information</h2>


<ol>
<li><a href="http://en.wikipedia.org/wiki/Comb_sort" title="Comb sort">Wikipedia - Comb sort</a></li>
</ol>


<p>Next up, we'll be looking at the <a href="http://buffered.io/posts/sorting-algorithms-the-gnome-sort/" title="Sorting Algorithms: The Gnome Sort">Gnome Sort</a>.</p>

<h2>Disclaimer</h2>


<p>I'm no expert, nor an authority. The post above is based on my experience and a bit of research. If you find something wrong with anything I've said please let me know. Comments and feedback are greatly appreciated.</p>

<p><em>Note: For those reading this article in an RSS reader, you may find the colours do not appear in the examples properly. For some reason the feed is stripping out some of the formatting. I will do my best to fix this up soon.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sorting Algorithms: The Cocktail Sort]]></title>
    <link href="http://buffered.io/posts/sorting-algorithms-the-cocktail-sort/"/>
    <updated>2008-08-29T21:44:00+10:00</updated>
    <id>http://buffered.io/posts/sorting-algorithms-the-cocktail-sort</id>
    <content type="html"><![CDATA[<p><img src="http://buffered.io/uploads/2008/08/cocktail.jpg" alt="Cocktail" title="Cocktail" style="float: right; margin-left: 5px; margin-bottom: 5px" />Welcome to the second post in my series on <a href="http://buffered.io/category/sorting/" title="Sorting @ OJ's rants">sorting</a> algorithms. This time we're going to talk about a sort that most people haven't heard a great deal about: the <strong>Cocktail Sort</strong>.</p>

<p>This algorithm was the next logical choice in the series because it is very similar to the <a href="http://buffered.io/posts/sorting-algorithms-the-bubble-sort/" title="Sorting Algorithms: The Bubble Sort">Bubble Sort</a> in the way that it operates. If you're yet to read the first in the series, head <a href="http://buffered.io/posts/sorting-algorithms-the-bubble-sort/" title="Sorting Algorithms: The Bubble Sort">over there now</a> as it will make this algorithm easier to understand.</p>

<!--more-->


<p>Fundamentally the algorithm is the same. The difference is that the Cocktail Sort iterates through a given <em>data set</em> in <strong>both</strong> directions when sorting. So let's break it down.</p>

<h2>Common Terms</h2>


<ul>
<li><em>Data set</em> - the array or list of items that is to be sorted.</li>
<li><em>n</em> - the number of elements in the <em>data set</em></li>
</ul>




<h2>The Algorithm</h2>


<p>Each iteration of the algorithm is broken up into two stages.</p>

<p>The first stage loops through the <em>data set</em> from bottom to top, just like the Bubble Sort. During the loop, adjacent items are compared. If at any point the value on the left is greater than the value on the right, the items are swapped. At the end of the first iteration, the largest number will reside at the end of the set.</p>

<p>The second stage loops through the <em>data set</em> in the <strong>opposite</strong> direction - starting from the item just before the most recently sorted item, and moving back towards the start of the list. Again, adjacent items are swapped if required.</p>

<p>The Cocktail Sort also fits in the category of <strong>Exchange Sorts</strong> due to the manner in which elements are moved inside the <em>data set</em> during the sorting process.</p>

<h2>The Example</h2>




<p>We will use the same initial <em>data set</em> that we used for the Bubble Sort to aid in highlighting the differences.</p>

<p>The initial set looks like this:</p>

<p><span class="eg">33 98 74 13 55 20 77 45 64 83</span></p>

<p>The first iteration starts at the beginning of the list, comparing the first two items (marked in red):</p>

<p><span class="eg"><b>33 98</b> 74 13 55 20 77 45 64 83</span></p>

<p>Since 33 is less than 98, no swapping needs to be done as they're already in the correct order. So we move on to the next comparison:</p>

<p><span class="eg">33 <b>98 74</b> 13 55 20 77 45 64 83</span></p>

<p>This time a swap is required as 98 is greater than 74:</p>

<p><span class="eg">33 <i>74 98</i> 13 55 20 77 45 64 83</span></p>

<p>We do the same again, this time starting at the third item:</p>

<p><span class="eg">33 74 <b>98 13</b> 55 20 77 45 64 83</span></p>

<p>Again, we need to swap the items since they're not in order:</p>

<p><span class="eg">33 74 <i>13 98</i> 55 20 77 45 64 83</span></p>

<p>We repeat this process until we get to the end of the list (marked in green):</p>

<p><span class="eg">33 74 13 55 20 77 45 64 83 <u>98</u></span></p>

<p>As was mentioned earlier, the result is that the largest number, <em>98</em> is placed at the end of the list. The next stage of the first iteration requires us to loop in the opposite direction. Since we know that <em>98</em> is in its rightful place, we start at the items immediately to the left:</p>

<p><span class="eg">33 74 13 55 20 77 45 <b>64 83</b> <u>98</u></span></p>

<p>We perform the same comparison as normal, and in this case we can see that we don't have to swap the items because 64 is less than 83. We move on to the next pair:</p>

<p><span class="eg">33 74 13 55 20 77 <b>45 64</b> 83 <u>98</u></span></p>

<p>Again, we find that a swap is not necessary because 45 is less than 64. Moving down the list again we compare the previous pair:</p>

<p><span class="eg">33 74 13 55 20 <b>77 45</b> 64 83 <u>98</u></span></p>

<p>This time we <strong>do</strong> want to swap the items, because 45 is less than 77, and hence the items are in the wrong order.</p>

<p><span class="eg">33 74 13 55 20 <i>45 77</i> 64 83 <u>98</u></span></p>

<p>With the swap complete we again move to the previous pair:</p>

<p><span class="eg">33 74 13 55 <b>20 45</b> 77 64 83 <u>98</u></span></p>

<p>Again, no swap needed, look at the previous pair:</p>

<p><span class="eg">33 74 13 <b>55 20</b> 45 77 64 83 <u>98</u></span></p>

<p>These two are not in the right order, so swap them:</p>

<p><span class="eg">33 74 13 <i>20 55</i> 45 77 64 83 <u>98</u></span></p>

<p>With the swap performed, we again move to the previous pair:</p>

<p><span class="eg">33 74 <b>13 20</b> 55 45 77 64 83 <u>98</u></span></p>

<p>No swap needed, go to the previous pair:</p>

<p><span class="eg">33 <b>74 13</b> 20 55 45 77 64 83 <u>98</u></span></p>

<p>These are out of order, so swap:</p>

<p><span class="eg">33 <i>13 74</i> 20 55 45 77 64 83 <u>98</u></span></p>

<p>Finally we look at the last pair in this stage:</p>

<p><span class="eg"><b>33 13</b> 74 20 55 45 77 64 83 <u>98</u></span></p>

<p>Again a swap is required:</p>

<p><span class="eg"><i>13 33</i> 74 20 55 45 77 64 83 <u>98</u></span></p>

<p>We're now done with the second stage, and as we can see we have the highest and lowest values at the end and start of the set (respectively):</p>

<p><span class="eg"><u>13</u> 33 74 20 55 45 77 64 83 <u>98</u></span></p>

<p>So at this point we're ready to iterate again, but we don't want to include the items that have already been sorted because we know they're in the right spot. Here's a short hand demo of both stages of the next iteration (remember, comparisons are in red, swaps are in blue, stores are in green):</p>

<p><span class="eg"><u>13</u> <b>33 74</b> 20 55 45 77 64 83 <u>98</u></span>
<span class="eg"><u>13</u> 33 <b>74 20</b> 55 45 77 64 83 <u>98</u></span>
<span class="eg"><u>13</u> 33 <i>20 74</i> 55 45 77 64 83 <u>98</u></span>
<span class="eg"><u>13</u> 33 20 <b>74 55</b> 45 77 64 83 <u>98</u></span>
<span class="eg"><u>13</u> 33 20 <i>55 74</i> 45 77 64 83 <u>98</u></span>
<span class="eg"><u>13</u> 33 20 55 <b>74 45</b> 77 64 83 <u>98</u></span>
<span class="eg"><u>13</u> 33 20 55 <i>45 74</i> 77 64 83 <u>98</u></span>
<span class="eg"><u>13</u> 33 20 55 45 <b>74 77</b> 64 83 <u>98</u></span>
<span class="eg"><u>13</u> 33 20 55 45 74 <b>77 64</b> 83 <u>98</u></span>
<span class="eg"><u>13</u> 33 20 55 45 74 <i>77 64</i> 83 <u>98</u></span>
<span class="eg"><u>13</u> 33 20 55 45 74 77 <b>64 83</b> <u>98</u></span>
<span class="eg"><u>13</u> 33 20 55 45 74 <b>77 64</b> <u>83</u> <u>98</u></span>
<span class="eg"><u>13</u> 33 20 55 45 74 <i>64 77</i> <u>83</u> <u>98</u></span>
<span class="eg"><u>13</u> 33 20 55 45 <b>74 64</b> 77 <u>83</u> <u>98</u></span>
<span class="eg"><u>13</u> 33 20 55 45 <i>64 74</i> 77 <u>83</u> <u>98</u></span>
<span class="eg"><u>13</u> 33 20 55 <b>45 64</b> 74 77 <u>83</u> <u>98</u></span>
<span class="eg"><u>13</u> 33 20 <b>55 45</b> 64 74 77 <u>83</u> <u>98</u></span>
<span class="eg"><u>13</u> 33 20 <i>45 55</i> 64 74 77 <u>83</u> <u>98</u></span>
<span class="eg"><u>13</u> 33 <b>20 45</b> 55 64 74 77 <u>83</u> <u>98</u></span>
<span class="eg"><u>13</u> <b>33 20</b> 45 55 64 74 77 <u>83</u> <u>98</u></span>
<span class="eg"><u>13</u> <i>20 33</i> 45 55 64 74 77 <u>83</u> <u>98</u></span>
<span class="eg"><u>13</u> <u>20</u> 33 45 55 64 74 77 <u>83</u> <u>98</u></span></p>

<p>The process repeats again. But this time as we iterate through, we can see that no swaps are required. The result after the next iterate is simple:</p>

<p><span class="eg"><u>13</u> <u>20</u> <u>33</u> <u>45</u> <u>55</u> <u>64</u> <u>74</u> <u>77</u> <u>83</u> <u>98</u></span></p>

<p>As we can see, using this algorithm to sort this particular data set results in less work than when using the Bubble Sort.</p>

<h2>The Implementation</h2>


<p>Here is a sample implementation written in <a href="http://en.wikipedia.org/wiki/C_Sharp" title="C Sharp">C#</a>. It is heavily commented in the hope that it will aid in understanding how the algorithm works:</p>

<p>{% codeblock lang:csharp %}
/// <summary>
/// Performs a cocktail sort on an array of integers.
/// </summary>
/// <param name="dataSet">An array of ints to be sorted.</param>
static void CocktailSortBasic(int[] dataSet)
{</p>

<pre><code>bool swapped = false;
int start = 0;
int end = dataSet.Length - 1;

do
{
    // make sure we reset the swapped flag on entering
    // the loop, because it might be true from a previous
    // iteration.
    swapped = false;

    // loop from bottom to top just like we do with
    // the bubble sort
    for (int i = start; i &lt; end; ++i)
    {
        if (dataSet[i] &gt; dataSet[i + 1])
        {
            Swap(dataSet, i, i + 1);
            swapped = true;
        }
    }

    // if nothing moved, then we're sorted.
    if (!swapped)
    {
        break;
    }

    // otherwise, reset the swapped flag so that it
    // can be used in the next stage
    swapped = false;

    // move the end point back by one, because we know
    // that the item at the end is in its rightful spot
    --end;

    // this time we loop from top to bottom, doing the
    // same comparison as in the previous stage
    for (int i = end - 1; i &gt;= start; --i)
    {
        if (dataSet[i] &gt; dataSet[i + 1])
        {
            Swap(dataSet, i, i + 1);
            swapped = true;
        }
    }

    // this time we increase the starting point, because
    // the last stage would have moved the next smallest
    // number to its rightful spot.
    ++start;
} while (swapped);
</code></pre>

<p>}
{% endcodeblock %}</p>

<h2>The Complexity</h2>


<p>Both space and time complexity are the same as that of the <a href="http://buffered.io/posts/sorting-algorithms-the-bubble-sort/" title="Sorting Algorithms: The Bubble Sort">Bubble Sort</a> for exactly the same reasons. That is, time complexity is O(n<sup>2</sup>), and space complexity for in-place sorting is O(1).</p>

<h2>A Note on Performance</h2>


<p>The Cocktail Sort can actually prove to be faster than the Bubble Sort in a fair few cases. This is due to the fact that we sort in both directions each iteration instead of just one.</p>

<p>Here's an example <em>data set</em> which would require 9 iterations with a Bubble Sort, but only 1 iteration (of two stages) with a Cocktail Sort:</p>

<p><span class="eg">20 33 45 55 64 74 77 83 98 13</span></p>

<p>The second stage of the Cocktail Sort would simply move the number <em>13</em> all the way down to the start of the list, at which point the list is then sorted. The Bubble Sort would move the number <em>13</em> left one place for each iteration.</p>

<p>In general, the Cocktail Sort will perform, at worst, the same as the Bubble Sort.</p>

<p><a name="CocktailSortBitBucket"></a></p>

<h2>Other Implementations</h2>


<p>I'm slowly gathering a collection of implementations of all the sorting algorithms, including the ones listed above, that I'm covering in this series and posting them up on <a href="http://www.bitbucket.org/OJ/sorting/overview/" title="Sorting @ OJ's BitBucket">BitBucket</a>. The Cocktail Sort implementations can be found <a href="http://www.bitbucket.org/OJ/sorting/src/acf7fe9d7127/02-CocktailSort/" title="CocktailSort @ OJ's BitBucket">here</a>.</p>

<p><em>Note: You'll need <a href="http://www.selenic.com/mercurial/" title="Mercurial">Mercurial</a> if you want to pull directly from the repository, otherwise you'll have to copy and paste from the web.</em></p>

<h2>References and Other Information</h2>


<ol>
<li><a href="http://en.wikipedia.org/wiki/Cocktail_sort" title="Cocktail sort">Wikipedia - Cocktail sort</a></li>
</ol>


<p>Next up, we'll be looking at the <strong>Comb Sort</strong>.</p>

<h2>Disclaimer</h2>


<p>I'm no expert, nor an authority. The post above is based on my experience and a bit of research. If you find something wrong with anything I've said please let me know. Comments and feedback are greatly appreciated.</p>

<p><em>Note: For those reading this article in an RSS reader, you may find the colours do not appear in the examples properly. For some reason the feed is stripping out some of the formatting. I will do my best to fix this up soon.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sorting Algorithms: The Bubble Sort]]></title>
    <link href="http://buffered.io/posts/sorting-algorithms-the-bubble-sort/"/>
    <updated>2008-08-14T20:27:00+10:00</updated>
    <id>http://buffered.io/posts/sorting-algorithms-the-bubble-sort</id>
    <content type="html"><![CDATA[<p><img src="http://buffered.io/uploads/2008/08/bubbles.jpg" alt="Bubbles" title="Bubbles" width="225" height="154" style="float: left; margin-right: 5px; margin-bottom: 5px" />This is the first of many posts covering the fascinating topic of <a href="http://buffered.io/category/sorting/" title="Sorting @ OJ's rants">sorting</a>.</p>

<p>I chose the Bubble Sort algorithm as the first to cover because of its simplicity. This algorithm tends to be the first sorting algorithm that is taught to students, and hence is a rather apt starting point.</p>

<p>Let's break it down.</p>

<!--more-->




<h2>Common Terms</h2>


<ul>
<li><em>Data set</em> - the array or list of items that is to be sorted.</li>
<li><em>n</em> - the number of elements in the <em>data set</em></li>
</ul>




<h2>The Algorithm</h2>


<p>The algorithm consists of a repeated iteration over the elements of the <em>data set</em>. In each iteration, adjacent elements are compared. If those two adjacent items are in the wrong order, they are swapped. The result of each iteration is that the next highest value is placed in the appropriate location in the <em>data set</em>. After repeating the iteration <em>n - 1</em> times, the entire <em>data set</em> will be sorted.</p>

<p>The Bubble Sort fits in the category of <strong>Exchange Sorts</strong> due to the manner in which elements are moved inside the <em>data set</em> during the sorting process.</p>

<h2>The Example</h2>




<p>We start with an unsorted <em>data set</em> of 10 elements which we want to sort in <em>ascending</em> order:</p>

<p><span class="eg">33 98 74 13 55 20 77 45 64 83</span></p>

<p>The start of the first iteration looks at the first two elements (marked in red):</p>

<p><span class="eg"><b>33 98</b> 74 13 55 20 77 45 64 83</span></p>

<p>As per the algorithm we compare the two values, swapping them if the first item is bigger than the second. In this case, 98 is bigger than 33, so no swap is required.</p>

<p>Next we look at the two adjacent items, starting at the second item in the list:</p>

<p><span class="eg">33 <b>98 74</b> 13 55 20 77 45 64 83</span></p>

<p>In this case 98 is greater than 74, so the items must be swapped (marked in blue):</p>

<p><span class="eg">33 <i>74 98</i> 13 55 20 77 45 64 83</span></p>

<p>We do the same again, this time starting at the third item:</p>

<p><span class="eg">33 74 <b>98 13</b> 55 20 77 45 64 83</span></p>

<p>Again, we need to swap the items since they're not in order:</p>

<p><span class="eg">33 74 <i>13 98</i> 55 20 77 45 64 83</span></p>

<p>We repeat this process until we get to the end of the list (marked in green):</p>

<p><span class="eg">33 74 13 55 20 77 45 64 83 <u>98</u></span></p>

<p>As we can see, the result is that the largest number is placed at the end of the list. This is the end of the first iteration.</p>

<p>We then iterate again but only cover the section of numbers that haven't already been sorted.</p>

<p><span class="eg"><b>33 74</b> 13 55 20 77 45 64 83 <u>98</u></span></p>

<p>No swap required, move to the next pair.</p>

<p><span class="eg">33 <b>74 13</b> 55 20 77 45 64 83 <u>98</u></span></p>

<p>Swap required:</p>

<p><span class="eg">33 <i>13 74</i> 55 20 77 45 64 83 <u>98</u></span></p>

<p>Move to the next pair:</p>

<p><span class="eg">33 13 <b>74 55</b> 20 77 45 64 83 <u>98</u></span></p>

<p>Again, swap required:</p>

<p><span class="eg">33 13 <i>55 74</i> 20 77 45 64 83 <u>98</u></span></p>

<p>We continue this trend for another iteration before hitting the following case:</p>

<p><span class="eg">33 13 55 20 <b>74 77</b> 45 64 83 <u>98</u></span></p>

<p>Here, there is no swap required, so we leave behind the number we've been "carrying" (74) and pick up number 77.</p>

<p><span class="eg">33 13 55 20 74 <b>77 45</b> 64 83 <u>98</u></span></p>

<p>The result of the iteration is as follows:</p>

<p><span class="eg">33 13 55 20 74 45 64 77 <u>83</u> <u>98</u></span></p>

<p>As we can see, this "bubbles" each of the numbers to the top of the list in the order of highest to lowest. Here is how the rest of the numbers are sorted at the end of each following iteration:</p>

<p><span class="eg">13 33 20 55 45 64 74 <u>77</u> <u>83</u> <u>98</u></span>
<span class="eg">13 20 33 45 55 64 <u>74</u> <u>77</u> <u>83</u> <u>98</u></span>
<span class="eg">13 20 33 45 55 <u>64</u> <u>74</u> <u>77</u> <u>83</u> <u>98</u></span>
<span class="eg">13 20 33 45 <u>55</u> <u>64</u> <u>74</u> <u>77</u> <u>83</u> <u>98</u></span>
<span class="eg">13 20 33 <u>45</u> <u>55</u> <u>64</u> <u>74</u> <u>77</u> <u>83</u> <u>98</u></span>
<span class="eg">13 20 <u>33</u> <u>45</u> <u>55</u> <u>64</u> <u>74</u> <u>77</u> <u>83</u> <u>98</u></span>
<span class="eg"><u>13</u> <u>20</u> <u>33</u> <u>45</u> <u>55</u> <u>64</u> <u>74</u> <u>77</u> <u>83</u> <u>98</u></span></p>

<p>Note that the last iteration results in two numbers being locked in due to the fact we no longer have any numbers to sort.</p>

<h2>The Implementation</h2>


<p>Here's a commented sample in <a href="http://en.wikipedia.org/wiki/C_Sharp" title="C Sharp">C#</a> which is easily translatable to many other languages:
{% codeblock lang:csharp %}
/// <summary>
/// This is the basic bubble sort algorithm, hard-coded to work
/// with integer values.
/// </summary>
/// <param name="dataSet">Array of integers to sort.</param>
static void BubbleSortBasic(int[] dataSet)
{</p>

<pre><code>// loop n-1 times.
for (int i = dataSet.Length - 1; i &gt; 0 ; --i)
{
    // for each loop, iterate through the first i
    // items (ie. the unsorted ones)
    for (int j = 0; j &lt; i; ++j)
    {
        // if adjacent items need to be swapped
        if (dataSet[j] &gt; dataSet[j + 1])
        {
            // swap them
            Swap(dataSet, j, j + 1);
        }
    }
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>A general form of this algorithm which applies to any comparable type can be found in the source repository listed <a href="#BubbleSortBitBucket">below</a>.</p>

<h2>A Minor Optimsation</h2>


<p>The Bubble Sort can be optimised very slightly, though it's not guaranteed to provide much benefit depending on the structure of the <em>data set</em> that is to be sorted.</p>

<p>If, for any iteration, there are no items swapped then all of the items in the <em>data set</em> must be in the correct order. As a result, subsequent iterations are unnecessary. The optimised version is listed below, again in C#:
{% codeblock lang:csharp %}
/// <summary>
/// This is the basic bubble sort algorithm, hard-coded to work
/// with integer values but with a slight difference - a minor
/// optimisation.
/// </summary>
/// <param name="dataSet">Array of integers to sort.</param>
static void BubbleSortBasicOptimised(int[] dataSet)
{</p>

<pre><code>// loop n-1 times.
for (int i = dataSet.Length - 1; i &gt; 0 ; --i)
{
    // keep track of whether items were swapped
    // for this iteration
    bool swapped = false;

    // for each loop, iterate through the first i
    // items (ie. the unsorted ones)
    for (int j = 0; j &lt; i; ++j)
    {
        // if adjacent items need to be swapped
        if (dataSet[j] &gt; dataSet[j + 1])
        {
            // swap them
            Swap(dataSet, j, j + 1);

            // indicate that we found a swap
            swapped = true;
        }
    }

    // if nothing was swapped, then we should
    // already have everything in order
    if (!swapped)
    {
        break;
    }
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p><em>Caveat</em>: This "optimisation" may actually result in lower performance, particularly in the case where every iteration results in a swap.</p>

<h2>The Complexity</h2>


<h3>Space Complexity</h3>


<p>Bubble Sorts are extremely efficient in terms of memory usage, due to the fact that all sorting and swapping operations are done on the original <em>data set</em>. Regardless of the size of the original <em>data set</em>, the amount of memory overhead is constant as we don't allocate any memory for each of the items. Hence, the space complexity is <strong>O(1)</strong> (in <a href="http://en.wikipedia.org/wiki/Big_O_notation" title="Big-O notation">Big-O notation</a>). This, of course, doesn't include the <strong>O(n)</strong> space complexity taken up by the original <em>data set</em>.</p>

<h3>Time Complexity</h3>


<p>This is where the Bubble Sort fails to shine. For each iteration <em>i</em> starting at <em>n</em>, we must loop through the previous <em>i - 1</em> elements and swap if required.</p>

<p>The first iteration loops through <em>n - 1</em> elements.
The second iteration loops through <em>n - 2</em> elements.
The third iteration loops through <em>n - 3</em> elements.
And so on.. which means the number of compares/swaps that we do is equal to:
(<em>n</em> - 1) + (<em>n</em> - 2) + (<em>n</em> - 3) ... + 2 + 1
This indicates that there <em>n</em> lots of <em>n - i</em>, or <em>n<sup>2</sup> - ni</em> (where <em>ni</em> varies for each iteration).</p>

<p>Give that the highest power of <em>n</em> is <strong>2</strong> this indicates a time complexity of <strong>O(n<sup>2</sup>)</strong>.</p>

<p>Or in layman's terms: it's f**king slow :)</p>

<p>Bubble Sorts should only be used on <em>data sets</em> that are rather small. If you're dealing with medium-sized or larger sets of data, then the Bubble Sort is not the right algorithm to choose. So what would be a better option? You'll have to read the rest of this series and answer that yourself ;)</p>

<p><a name="BubbleSortBitBucket"></a></p>

<h2>Other Implementations</h2>


<p>I'm slowly gathering a collection of implementations of all the sorting algorithms, including the ones listed above, that I'm covering in this series and posting them up on <a href="http://www.bitbucket.org/OJ/sorting/overview/" title="Sorting @ OJ's BitBucket">BitBucket</a>. The Bubble Sort implementations can be found <a href="http://www.bitbucket.org/OJ/sorting/src/2ce17136dbac/01-BubbleSort/" title="BubbleSort @ OJ's BitBucket">here</a>.</p>

<p><em>Note: You'll need <a href="http://www.selenic.com/mercurial/" title="Mercurial">Mercurial</a> if you want to pull directly from the repository, otherwise you'll have to copy and paste from the web.</em></p>

<h2>Closing Thoughts</h2>


<p>I haven't included information on multithreading because the post would be insanely big. I will put up a follow-up post covering multithreading another day. The code stored in the BitBucket repository contains a sample of how you might use multithreading in conjunction with this sorting algorithm.</p>

<p>To wrap up, Bubble Sorts are easy to understand and are a great place to start when learning sorting algorithms. Unfortunately, this simplicity results in a fairly expensive and slow sorting implementation which really isn't an option when dealing with anything other than small <em>data sets</em>.</p>

<h2>References and Other Information</h2>


<ol>
<li><a href="http://en.wikipedia.org/wiki/Bubble_sort" title="Bubble sort">Wikipedia - Bubble sort</a></li>
</ol>


<p>Next up, we'll be looking at the <a href="http://buffered.io/posts/sorting-algorithms-the-cocktail-sort/" title="Sorting Algorithms: The Cocktail Sort">Cocktail Sort</a>.</p>

<h2>Disclaimer</h2>


<p>I'm no expert, nor an authority. The post above is based on my experience and a bit of research. If you find something wrong with anything I've said please let me know. Comments and feedback are greatly appreciated.</p>
]]></content>
  </entry>
  
</feed>
