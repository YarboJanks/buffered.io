<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Series: Project Euler | OJ's rants]]></title>
  <link href="http://buffered.io/series/project-euler/atom.xml" rel="self"/>
  <link href="http://buffered.io/"/>
  <updated>2012-03-11T14:48:50+10:00</updated>
  <id>http://buffered.io/</id>
  <author>
    <name><![CDATA[OJ Reeves]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Project Euler #1]]></title>
    <link href="http://buffered.io/posts/project-euler-1/"/>
    <updated>2008-03-17T17:31:00+10:00</updated>
    <id>http://buffered.io/posts/project-euler-1</id>
    <content type="html"><![CDATA[<p><strong>WARNING!</strong> This post contains a spoiler for Problem #1 listed at <a href="http://projecteuler.net/" title="Project Euler">Project Euler</a>. Do not read the rest of this post if you're planning to attempt to solve the problem yourself.</p>

<!--more-->


<p>I decided to work my way through these problems using <a href="http://www.haskell.org/" title="Haskell">Haskell</a>, as I felt it'd be a great way to learn the language (or at least start to get familiar with it).</p>

<p><a href="http://projecteuler.net/index.php?section=problems&amp;id=1" title="Problem #1">Problem #1</a> in the series is a nice "starter" question. It's a simple one to get you going, which for me was great since I am a bit of a Haskell beginner:</p>

<blockquote><p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.</p>

<p>Find the sum of all the multiples of 3 or 5 below 1000.</p></blockquote>

<p>Here is my Haskell source that generates the required answer:</p>

<p>{% codeblock lang:haskell %}
sum [ n | n &lt;- [1..999], ((mod n 3) == 0) || ((mod n 5) == 0) ]
{% endcodeblock %}</p>

<p>Don't you just love how concise the answer is? If you're like me and are new to Haskell, let me explain it a little.</p>

<ol>
<li><strong><code>[1..999]</code></strong> - this generates a list of values from 1 to 999 inclusive.</li>
<li><strong><code>[ value | item &amp;lt;- source list, condition ]</code></strong> - this is the basic <a href="http://en.wikipedia.org/wiki/List_comprehension" title="List Comprehension">list comprehension</a> syntax in Haskell (basically this is how you generate lists from other lists). Here is the breakdown.

<ol>
<li><em>source list</em> is a reference to a list which is used as the source to generate the new list.</li>
<li><em>item</em> is the variable that is an alias for each item in the source list. This is usually referenced in the <em>value</em> expression.</li>
<li><em>condition</em> is a boolean condition that indicates whether or not a value should be included in the list.</li>
<li><em>value</em> is the final expression that gets evaluated and stored in the list. The expression is only evaluated and added to the list <em>if the condition is true</em></li>
</ol>
</li>
<li><strong><code>mod n 3</code></strong> - this evaluates "n modulo 3", and hence gives the remainder when <em>n</em> is divided by 3.</li>
<li><strong><code>((mod n 3) == 0) || ((mod n 5) == 0)</code></strong> - this is a condition that evaluates to true if n is evenly divisible by 3 or 5.</li>
<li><strong><code>[ n | n &amp;lt;- [1..999], ((mod n 3) == 0) || ((mod n 5) == 0) ]</code></strong> - for each item <em>n</em> in the list of numbers 1 through 999, if the number is evenly divisible by 3 or 5, then include it in the list.</li>
<li><strong><code>sum</code></strong> - this function simply produces the sum of all the numbers in the given list.</li>
</ol>


<p>Pretty simple really isn't it :) Enjoy.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler #2]]></title>
    <link href="http://buffered.io/posts/project-euler-2/"/>
    <updated>2008-03-18T11:28:00+10:00</updated>
    <id>http://buffered.io/posts/project-euler-2</id>
    <content type="html"><![CDATA[<p><strong>WARNING!</strong> This post contains a spoiler for Problem #2 listed at <a href="http://projecteuler.net/" title="Project Euler">Project Euler</a>. Do not read the rest of this post if you're planning to attempt to solve the problem yourself.</p>

<!--more-->


<p><a href="http://projecteuler.net/index.php?section=problems&id=2">Problem #2</a> in the series is a little step up from the previous question, and involves a little more thought:<blockquote><p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</p>

<p>Find the sum of all the even-valued terms in the sequence which do not exceed four million.</p></blockquote></p>

<p>Here is my Haskell source that generates the required answer:
{% codeblock lang:haskell %}
-- Infinite list of Fibonacci numbers
fibs :: [Integer]
fibs = 1 : 2 : [ n | n &lt;- zipWith (+) (tail fibs) fibs ]</p>

<p>-- function that sums even values of fibs up to a number
sumEvenFibsTo :: Integer -> Integer
sumEvenFibsTo i = sum [ n | n &lt;- takeWhile (&lt;i) fibs, ((mod n 2) == 0)]</p>

<p>-- main - the programs entry point when compiled
main :: IO ()
main = print $ sumEvenFibsTo 4000000
{% endcodeblock %}</p>

<p>As we can see it's a little more complicated than the previous question, but isn't too difficult either. I won't go into the same level of detail as I did before when explaining the solution as I think most of it is obvious. Instead I'll just explain the bits that are a little convoluted:<ol><li><strong>tail</strong> - returns the list with the first item (the <em>head</em>) removed.</li><li><strong>zipWith</strong> - this is a built-in function that is part of <a href="http://www.haskell.org/hoogle/hoodoc.cgi?module=Prelude&mode=module" title="Prelude">Prelude</a>. It takes two lists (the last two parameters) and iterates through each at the same time. For each pair of items (one from each list) it applies the given function.</li><li><strong>zipWith (+) (tail fibs) fibs</strong> - create another list which is made up of the sum of each item in fibs with each item in the tail of fibs.</li><li><strong>takeWhile</strong> - takes from the head of the list until the value meets a given condition.</li><li><strong>print</strong> - displays a value on the screen.</li><li><strong>$</strong> - this is used as a way of separating function calls. Haskell is aggressive with its argument passing, and hence lots of parenthesis need to be used to make sure it's obvious what things are associated with each other. the <em>$</em> operator is just another way of doing the same thing without using parenthesis.</li></ol>
Again it's a neat solution. Nice and concise. The kicker here is the definition of <em>fibs</em>, the infinite recursive array. In Haskell, you can define a function using references to itself. Lists are just the same, as they're not evaluated until run-time. So you can define a list with no bounds, and at run-time you have the responsibility of making sure you don't try and parse the entire structure. This is where the <em>takeWhile</em> function comes in to our solution, we only take values while they're less than 4,000,000. Because we know that the Fibonacci sequence always increases in size, we know that it will eventually end.</p>

<p>I'll leave it to you to get your head around the recursive definition. If you want more clarification, just post a comment. Enjoy :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler #3]]></title>
    <link href="http://buffered.io/posts/project-euler-3/"/>
    <updated>2008-03-19T21:06:00+10:00</updated>
    <id>http://buffered.io/posts/project-euler-3</id>
    <content type="html"><![CDATA[<p><strong>WARNING!</strong> This post contains a spoiler for Problem #3 listed at <a href="http://projecteuler.net/" title="Project Euler">Project Euler</a>. Do not read the rest of this post if you're planning to attempt to solve the problem yourself.</p>

<!--more-->


<p><a href="http://projecteuler.net/index.php?section=problems&id=3">Problem #3</a> in the series is the first one to bring in prime numbers. Here's the question:<blockquote><p>The prime factors of 13195 are 5, 7, 13 and 29.</p>

<p>What is the largest prime factor of the number 600851475143 ?</p></blockquote>
For this particular problem I decided to avoid generating prime numbers because that takes ages. I had a feeling that later on down the track I was going to encounter a problem where I would need to generate primes, but for this problem I didn't find it necessary.</p>

<p>Instead, I attempted to use my noggin'. Up there for thinkin', down there for dancin'. Here's my Haskell source:
{% codeblock lang:haskell %}
biggestDivisor :: Integer -> Integer
biggestDivisor n</p>

<pre><code>          | even n    = biggestDivisor (div n 2)
          | otherwise = m n 3
            where m n d
                      | d &gt;= n        = d
                      | mod n d == 0  = m (div n d) d
                      | otherwise     = m n (d + 2)
</code></pre>

<p>main :: IO ()
main = print $ biggestDivisor 600851475143
{% endcodeblock %}</p>

<p>Don't ya just love built-in Big Integer support? :)</p>

<p>This obviously works from the bottom up. It starts with a special case with an even number. It keeps dividing by two until it's no longer even. At this point, it begins factorising using odd numbers starting at 3. The loop finishes when the last found factor is bigger than the number that is being factored. This works because as we find the factors, we divide the number by the factor. This keeps reducing the size of the number we're factorising, while increasing the size of the factors.</p>

<p>Pretty simple really isn't it! Thoughts?</p>

<p><strong>Note:</strong> I'm assuming that nobody is going to call this function that is a multiple of 2!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler #4]]></title>
    <link href="http://buffered.io/posts/project-euler-4/"/>
    <updated>2008-03-21T13:23:00+10:00</updated>
    <id>http://buffered.io/posts/project-euler-4</id>
    <content type="html"><![CDATA[<p><strong>WARNING!</strong> This post contains a spoiler for Problem #4 listed at <a href="http://projecteuler.net/" title="Project Euler">Project Euler</a>. Do not read the rest of this post if you're planning to attempt to solve the problem yourself.</p>

<!--more-->


<p>The next in the series, <a href="http://projecteuler.net/index.php?section=problems&id=4">Problem #4</a>, isn't a particularly difficult one, but it could pose some interesting issues depending on which language you use as well as which method you use. It reads:<blockquote><p>A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91  99.</p>

<p>Find the largest palindrome made from the product of two 3-digit numbers.</p></blockquote>
Thankfully, the built-in features of our chosen language, Haskell, make this problem extremely simple. The obvious way to solve this problem is brute force. So that's exactly what I did with a bit of tweaking. For those following my Euler posts so far who are also new to Haskell, you may find there's some additional syntax and functions here that you haven't seen before.</p>

<p>{% codeblock lang:haskell %}
-- A function that determines if a number is a palindromic number
isPalindrome :: Integer -> Bool
isPalindrome n = n == (read (reverse (show n))::Integer)</p>

<p>-- the solution to the question
main :: IO()
main = print $ maximum [ a * b | a &lt;- [100..999], b &lt;- [a..999], isPalindrome (a * b) ]
{% endcodeblock %}</p>

<p>It is fairly easy to understand so long as you keep the following in mind:</p>

<ol><li><strong>show</strong> - essentially converts a value to a string representation. So in our case, it converts the Integer to a String (or [Char] as it is in fact behind the scenes)</li><li><strong>reverse</strong> - reverses a list. So we take the list of characters from the previous call, and reverse it.</li><li><strong>read</strong> - reads a string of characters, and converts it into another type based on the one specified (in our case "::Integer" says to make the value an Integer)</li><li><strong>maximum</strong> - returns the largest numeric value found in a list.</li></ol>


<p>Yet another neat little solution. Essentially a two-liner! I can't see that happening in an imperative language :)</p>

<p>But what is the trade-off? Since this is the first brute force solution to a problem that might be faster solved by doing something smarter, let's see how long it takes. Here's a profile dump from GHC:</p>

<pre><code>  Fri Mar 21 13:13 2008 Time and Allocation Profiling Report  (Final)

     main +RTS -p -RTS

  total time  =        8.24 secs   (412 ticks @ 20 ms)
  total alloc = 1,793,269,760 bytes  (excludes profiling overheads)

COST CENTRE                    MODULE               %time %alloc

CAF                            Main                 100.0  100.0

                                                individual    inherited
COST CENTRE    MODULE         no.    entries  %time %alloc   %time %alloc

MAIN           MAIN             1           0   0.0    0.0   100.0  100.0
 CAF           Main           152           6 100.0  100.0   100.0  100.0
 CAF           Text.Read.Lex  129           8   0.0    0.0     0.0    0.0
 CAF           GHC.Read       124           1   0.0    0.0     0.0    0.0
 CAF           GHC.Handle      88           4   0.0    0.0     0.0    0.0
</code></pre>

<p>Total time = <strong>8.24 secs</strong>. Not blindingly fast, but pretty darned good considering how long it took to write the solution!</p>

<p>Thoughts?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler #4 - Reprise]]></title>
    <link href="http://buffered.io/posts/project-euler-4-reprise/"/>
    <updated>2008-03-22T13:59:00+10:00</updated>
    <id>http://buffered.io/posts/project-euler-4-reprise</id>
    <content type="html"><![CDATA[<p>After publishing the performance stats of my <a href="http://buffered.io/posts/project-euler-4/" title="Project Euler #4">previous solution to Project Euler #4</a>, I got thinking about how I might improve things. I didn't want to be overly anal with regards to things such as memory allocations, because it's easy to get stuck in the perpetual loop of attempted optimisations. Instead I wanted to think of a method that wasn't as brute force as the previous one. If you're interested to see what I did, read on (<strong>Note:</strong> This is a spoiler for the problem, just like the last post was).</p>

<!--more-->


<p>Let's start by looking at the source, which I commented heavily:
{% codeblock lang:haskell %}
-- A function that determines if a number is a palindromic number
isPalindrome :: Integer -> Bool
isPalindrome n = n == (read (reverse (show n))::Integer)</p>

<p>-- create a bunch of possible factors knowing what we know about the problem.
-- a palindrome of 6 digits is in the form: abccba (we'll call this x)
-- x = abccba
-- so therefore x = 100000a + 10000b + 1000c + 100c + 10b + 1a
-- hence x = 100001a + 10010b + 1100c
-- That being the case, we can factor out the greatest common factor of
-- 100001, 10010 and 1100 which will give us a number that the result
-- must be evenly divisible by. So we generate a list, starting with the
-- first number >= 100 which is a multiple of that value. We increment by
-- that value each time. This should give us a much smaller list to work
-- against and hence reduce the time to calculate the answer.
possibleFactors :: [Integer]
possibleFactors = [ s, o..999 ]</p>

<pre><code>            where
              d = (gcd (gcd 1100 10010) 100001) -- gives the magic value (11 ;))
              s = d * ceiling (100.0 / (fromIntegral d)) -- the starting point (110 ;))
              o = s + d -- the next value in the list (121 ;))
</code></pre>

<p>-- the solution to the question - this time using the list of possible factors
-- and all the other numbers from 100 to 999
main :: IO()
main = print $ maximum [ a * b | a &lt;- possibleFactors, b &lt;- [100..999], isPalindrome (a * b) ]
{% endcodeblock %}</p>

<p>If that's not clear, then drop me a comment and I'll try and explain further. In a nutshell, using the properties we know of the target result, we can narrow down the set of values that we can use to test.</p>

<p>Proof is in the perf! Check out the stats:</p>

<pre><code>  Sat Mar 22 13:43 2008 Time and Allocation Profiling Report  (Final)

     main +RTS -p -RTS

  total time  =        2.36 secs   (118 ticks @ 20 ms)
  total alloc = 327,270,176 bytes  (excludes profiling overheads)

COST CENTRE                    MODULE               %time %alloc

CAF                            Main                 100.0  100.0

                                                  individual    inherited
COST CENTRE    MODULE            no.    entries  %time %alloc   %time %alloc

MAIN           MAIN                1           0   0.0    0.0   100.0  100.0
 CAF           Main              152          17 100.0  100.0   100.0  100.0
 CAF           Text.Read.Lex     129           8   0.0    0.0     0.0    0.0
 CAF           GHC.Real          127           1   0.0    0.0     0.0    0.0
 CAF           GHC.Read          124           1   0.0    0.0     0.0    0.0
 CAF           GHC.Float         123           9   0.0    0.0     0.0    0.0
 CAF           GHC.Handle         88           4   0.0    0.0     0.0    0.0
</code></pre>

<p>So the total time dropped to <strong>2.26 seconds</strong>. Quite an improvement over the previous implementation (around 4x faster).</p>

<p>Thoughts on further improvements?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler #5]]></title>
    <link href="http://buffered.io/posts/project-euler-5/"/>
    <updated>2008-03-23T15:26:00+10:00</updated>
    <id>http://buffered.io/posts/project-euler-5</id>
    <content type="html"><![CDATA[<p><strong>WARNING!</strong> This post contains a spoiler for Problem #5 listed at <a href="http://projecteuler.net/" title="Project Euler">Project Euler</a>. Do not read the rest of this post if you're planning to attempt to solve the problem yourself.</p>

<!--more-->


<p><a href="http://projecteuler.net/index.php?section=problems&id=5">Problem #5</a> is a great little problem that requires a little maths knowledge to be able to solve in a reasonable period of time. Let's take a look at the question:<blockquote><p>2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.</p>

<p>What is the smallest number that is <u>evenly divisible</u> by all of the numbers from 1 to 20?</p></blockquote>
Brute force? Hrm, I don't think so :) It'd take an ice age. Nope, instead we need to do a bit of <a href="http://en.wikipedia.org/wiki/Least_common_multiple" title="Least common multiple">research</a> to help come up with a smarter solution.</p>

<p>In short, the best way is to find the lowest common multiple (LCM) for each of the numbers respectively. Thankfully, Haskell comes with a couple of handy functions which make it really easy to iterate over a list and find the LCM of each pair of items:<ol><li><strong>lcm</strong> - finds the LCM of two numbers.</li><li><strong>fold*</strong> - iterates over a list and applies a function to each item pair iteratively using the result on the next item. There are many flavours, but we'll use <a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3Afoldl1" title="foldl1">foldl1</a>.</li></ol>
So here it is, the solution to the problem in all its glory:
{% codeblock lang:haskell %}
main :: IO ()
main = print $ foldl1 (lcm) [2..20]
{% endcodeblock %}</p>

<p>Genius isn't it :) We could actually avoid all the numbers from 2 to 10 if we wanted, because we know that multiples of those numbers appear from 11 to 20, so to reduce a bit of time we could do this:
{% codeblock lang:haskell %}
main :: IO ()
main = print $ foldl1 (lcm) [11..20]
{% endcodeblock %}</p>

<p>That gives the same result just a tiny bit quicker.</p>

<p>Now it's time for me to embarass myself a little. Before I came to the "neat" little conclusion above, I actually did a fair bit of work hand-coding my own solution. I was trying to be too tricky for my own good, and as a result I paid the price of wasting a lot of time. Having said that, I learned a lot about the language when I wrote this, so it wasn't a <em>complete</em> waste of time. The code below is what happens when you attempt a problem without actually doing any research on it :) Enjoy!
{% codeblock lang:haskell %}
import List</p>

<p>-- Prime factor is a tuple where the first value is
-- the number, and the second value is the power that
-- the number is to be raised to. eg:
-- (2, 4) = 2 ** 4
type PrimeFactor = (Integer, Int)</p>

<p>-- Function that factorises a number into a list of
-- prime factors. eg:
-- factorise 24 = [2, 2, 2, 3]
factorise :: Integer -> [Integer]
factorise 1 = []
factorise n | even n    = 2 : factorise (div n 2)</p>

<pre><code>        | otherwise = f n 3
      where
        f 1 _ = []
        f n d | mod n d == 0  = d : f (div n d) d
              | otherwise     = f n (d + 2)
</code></pre>

<p>-- Convert a list of factors into a list of prime factors. eg:
-- power [2, 2, 2, 3] = [(2, 3), (3, 1)]
power :: [Integer] -> [PrimeFactor]
power l = map (\l -> (head l, length l)) $ group l</p>

<p>-- Convert a list of prime factors into a normalise list where
-- we keep the instance of a number with the highest power. eg:
-- normalise [(2, 1), (2, 2), (3, 3), (3, 2)] = [(2, 2), (3, 3)]
normalise :: [PrimeFactor] -> [PrimeFactor]
normalise []      = []
normalise (n:ns)  = [f n ns] ++ normalise (filter (\x -> fst x /= fst n) ns)</p>

<pre><code>      where
        f n []          = n
        f (n, p) (l:ls) | n == fst l &amp;&amp; p &lt;= snd l  = f l ls
                        | otherwise                 = f (n, p) ls
</code></pre>

<p>-- expand the list of prime factors and multiply them all out. eg:
-- expand [(2, 2), (3, 3)] = 2 <strong> 2 * 3 </strong> 3 = 8 * 9 = 72
expand :: [PrimeFactor] -> Integer
expand []           = 0
expand ((n, p):[])  = n ^ p
expand ((n, p):ls)  = n ^ p * expand ls</p>

<p>-- helper function that takes a list of prime factor lists and
-- generates the resulting product number (as per the question)
eval :: [[PrimeFactor]] -> Integer
eval = expand . normalise . concat</p>

<p>-- standard IO monad to solve and print to screen
-- note, we don't need to include the numbers from 1 to 10
-- because the numbers from 11 to 20 cover those values as
-- factors!
main :: IO ()
main = print $ eval $ map (\l -> power (factorise l)) [11..20]
{% endcodeblock %}</p>

<p>Isn't that just terrific :P Not only is it huge, but it just stinks of "n00b". You can tell that it wasn't written by an experienced Haskeller.</p>

<p>Thoughts?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler #6]]></title>
    <link href="http://buffered.io/posts/project-euler-6/"/>
    <updated>2008-03-28T21:06:00+10:00</updated>
    <id>http://buffered.io/posts/project-euler-6</id>
    <content type="html"><![CDATA[<p><strong>WARNING!</strong> This post contains a spoiler for Problem #6 listed at <a href="http://projecteuler.net/" title="Project Euler">Project Euler</a>. Do not read the rest of this post if you're planning to attempt to solve the problem yourself.</p>

<!--more-->


<p><a href="http://projecteuler.net/index.php?section=problems&id=6">Problem #6</a> was a <em>little</em> bit of a disappointment, but I think that's because the solution was so extremely simple using Haskell. Again, we'll check out the question first:<blockquote><p>The sum of the squares of the first ten natural numbers is,
1<sup>2</sup> + 2<sup>2</sup> + ... + 10<sup>2</sup> = 385</p>

<p>The square of the sum of the first ten natural numbers is,
(1 + 2 + ... + 10)<sup>2</sup> = 55<sup>2</sup> = 3025</p>

<p>Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 - 385 = 2640.</p>

<p>Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.</p></blockquote>Now there are two main ways of doing this. The first requires knowledge of the properties of each of the two "bits" that we need to determine. If you Google enough, you'll find information which leads you to two different formulae; one which gives you the sum of the squares, the other the square of the sums. These will tell you how to solve each in O(1) time. Combine the two and you'll have a magic formula for solving the problem in a single step.</p>

<p>As for me, after doing the research I found no thrill in writing a function which took an integer and returned an integer that's the result of a basic equation. So instead, I wrote the following:
{% codeblock lang:haskell %}
main :: IO ()
main = print $ (sum [1..100]) ^ 2 - sum [ x<sup>2</sup> | x &lt;- [1..100] ]
{% endcodeblock %}</p>

<p>Nice and concise. Sure it takes longer as the numbers increase, but what the hell! If I need to do it in the real world I'll use the method that I haven't posted :).</p>

<p>I'd ask for thoughts, but for this problem there really aren't too many that can be had! On to the next problem.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler #7]]></title>
    <link href="http://buffered.io/posts/project-euler-7/"/>
    <updated>2008-06-15T04:53:00+10:00</updated>
    <id>http://buffered.io/posts/project-euler-7</id>
    <content type="html"><![CDATA[<p><strong>WARNING!</strong> This post contains a spoiler for Problem #7 listed at <a href="http://projecteuler.net/" title="Project Euler">Project Euler</a>. Do not read the rest of this post if you're planning to attempt to solve the problem yourself.</p>

<!--more-->


<p><a href="http://projecteuler.net/index.php?section=problems&id=7">Problem #7</a> was as boring as batshit (to be quite frank). The only reason I'm posting about it is to keep <a href="http://berkshirehunt.com/" title="Berkshire Hunt">The Head</a> happy ;)</p>

<p>The reason I thought it was boring was because it was just the age-old problem of "how fast can you generate primes":<blockquote><p>
By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.</p>

<p>What is the 10001st prime number?</p></blockquote>
A simple search of the web reveals a million different ways of solving this problem -- mostly written by people smarter than me :)</p>

<p>So did I cheat? No I didn't. I wrote the standard <a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" title="Sieve of Eratosthenes">Sieve of Eratosthenes</a> implementation in Haskell and got the answer in a respectable amount of time. Exciting stuff :|</p>

<p>I browsed around the web a little bit after solving the problem because I was interested to see how others might have solved it using Haskell. Yes, I am aware that there is a <a href="" title="">whole page dedicated to it</a> but that wasn't enough.</p>

<p>After a bit of a search, I stumbled across this little doozy. If you can make heads or tails of it you're a better man than I ;) It's quite a mind job to get your head around how this code works. This is an exercise I leave to the reader.
{% codeblock lang:haskell %}
merge :: (Ord a) => [a] -> [a] -> [a]
merge xs@(x:xt) ys@(y:yt) =
  case compare x y of</p>

<pre><code>LT -&gt; x : (merge xt ys)
EQ -&gt; x : (merge xt yt)
GT -&gt; y : (merge xs yt)
</code></pre>

<p>diff :: (Ord a) => [a] -> [a] -> [a]
diff xs@(x:xt) ys@(y:yt) =
  case compare x y of</p>

<pre><code>LT -&gt; x : (diff xt ys)
EQ -&gt; diff xt yt
GT -&gt; diff xs yt
</code></pre>

<p>primes, nonprimes :: [Integer]
primes    = [2, 3, 5] ++ (diff [7, 9 ..] nonprimes)
nonprimes = foldr1 f $ map g $ tail primes
  where</p>

<pre><code>f (x:xt) ys = x : (merge xt ys)
g p         = [ n * p | n &lt;- [p, p + 2 ..]]
</code></pre>

<p>main :: IO ()
main = print $ primes !! 10000
{% endcodeblock %}</p>

<p>Enjoy :)</p>

<p>PS. Jon - are ya happy now? :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler #8]]></title>
    <link href="http://buffered.io/posts/project-euler-8/"/>
    <updated>2008-07-24T20:55:00+10:00</updated>
    <id>http://buffered.io/posts/project-euler-8</id>
    <content type="html"><![CDATA[<p><strong>WARNING!</strong> This post contains a spoiler for Problem #8 listed at <a href="http://projecteuler.net/" title="Project Euler">Project Euler</a>. Do not read the rest of this post if you're planning to attempt to solve the problem yourself.</p>

<!--more-->


<p><a href="http://projecteuler.net/index.php?section=problems&id=8">Problem #8</a> was thankfully a great deal more interesting than <a href="http://buffered.io/posts/project-euler-7/" title="Project Euler #7">the last problem</a>. It goes as follows..</p>

<blockquote><p>Find the greatest product of five consecutive digits in the 1000-digit number.


       73167176531330624919225119674426574742355349194934
       96983520312774506326239578318016984801869478851843
       85861560789112949495459501737958331952853208805511
       12540698747158523863050715693290963295227443043557
       66896648950445244523161731856403098711121722383113
       62229893423380308135336276614282806444486645238749
       30358907296290491560440772390713810515859307960866
       70172427121883998797908792274921901699720888093776
       65727333001053367881220235421809751254540594752243
       52584907711670556013604839586446706324415722155397
       53697817977846174064955149290862569321978468622482
       83972241375657056057490261407972968652414535100474
       82166370484403199890008895243450658541227588666881
       16427171479924442928230863465674813919123162824586
       17866458359124566529476545682848912883142607690042
       24219022671055626321111109370544217506941658960408
       07198403850962455444362981230987879927244284909188
       84580156166097919133875499200524063689912560717606
       05886116467109405077541002256983155200055935729725
       71636269561882670428252483600823257530420752963450

</p></blockquote>


<p>I'm keeping with my <a href="http://haskell.org/" title="Haskell">Haskell</a> theme and abusing some of the nice feature of Functional Programming to nail this one.</p>

<p>Here's my solution:
{% codeblock lang:haskell %}
-- ord is required to convert chars to ints
import Data.Char (ord)</p>

<p>-- a string representation of the large number
number :: String
number =</p>

<pre><code> "73167176531330624919225119674426574742355349194934"
</code></pre>

<p>  ++ "96983520312774506326239578318016984801869478851843"
  ++ "85861560789112949495459501737958331952853208805511"
  ++ "12540698747158523863050715693290963295227443043557"
  ++ "66896648950445244523161731856403098711121722383113"
  ++ "62229893423380308135336276614282806444486645238749"
  ++ "30358907296290491560440772390713810515859307960866"
  ++ "70172427121883998797908792274921901699720888093776"
  ++ "65727333001053367881220235421809751254540594752243"
  ++ "52584907711670556013604839586446706324415722155397"
  ++ "53697817977846174064955149290862569321978468622482"
  ++ "83972241375657056057490261407972968652414535100474"
  ++ "82166370484403199890008895243450658541227588666881"
  ++ "16427171479924442928230863465674813919123162824586"
  ++ "17866458359124566529476545682848912883142607690042"
  ++ "24219022671055626321111109370544217506941658960408"
  ++ "07198403850962455444362981230987879927244284909188"
  ++ "84580156166097919133875499200524063689912560717606"
  ++ "05886116467109405077541002256983155200055935729725"
  ++ "71636269561882670428252483600823257530420752963450"</p>

<p>-- converts the number to a list of Int values
numberList :: [Int]
numberList = map (\n -> ord n - ord '0') number</p>

<p>-- breaks up the number list into chunks of 5 digits
chunks :: [[Int]]
chunks = c' numberList 5 995
  where</p>

<pre><code>c' _ _ 0 = []
c' l n c = (take n l) : c' (tail l) n (c - 1)
</code></pre>

<p>-- main function iterates over the list of chunks,
-- calculates the product of each of the chunks and
-- then determines the biggest result
main :: IO ()
main = print $ foldr1 max (map product chunks)
{% endcodeblock %}</p>

<p>The comments are pretty descriptive of what goes on. It turns out that the solution isn't that shabby in the performance stakes either:</p>

<pre><code>Thu Jul 24 20:46 2008 Time and Allocation Profiling Report  (Final)

     main +RTS -p -RTS

  total time  =        0.00 secs   (0 ticks @ 20 ms)
  total alloc =     571,224 bytes  (excludes profiling overheads)

COST CENTRE   MODULE  %time %alloc

CAF           Main      0.0   99.8

                                           individual    inherited
COST CENTRE   MODULE        no.  entries  %time %alloc   %time %alloc

MAIN          MAIN            1         0   0.0    0.0     0.0  100.0
 CAF          Main          152        15   0.0   99.8     0.0   99.8
 CAF          GHC.Handle     88         4   0.0    0.2     0.0    0.2
</code></pre>

<p>I still love how concise and easy the solutions to problems like this are in Haskell.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler #9]]></title>
    <link href="http://buffered.io/posts/project-euler-9/"/>
    <updated>2008-07-25T22:08:00+10:00</updated>
    <id>http://buffered.io/posts/project-euler-9</id>
    <content type="html"><![CDATA[<p><strong>WARNING!</strong> This post contains a spoiler for Problem #9 listed at <a href="http://projecteuler.net/" title="Project Euler">Project Euler</a>. Do not read the rest of this post if you're planning to attempt to solve the problem yourself.</p>

<!--more-->


<p><a href="http://projecteuler.net/index.php?section=problems&id=9">Problem #9</a> takes a turn back into the math theory and forces you to think about Pythagorean triplets. It goes as follows:<blockquote><p>
A Pythagorean triplet is a set of three natural numbers, a  b  c, for which,
&nbsp;&nbsp;&nbsp;&nbsp;a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup></p>

<p>For example, 3<sup>2</sup> + 4<sup>2</sup> = 9 + 16 = 25 = 5<sup>2</sup>.</p>

<p>There exists exactly one Pythagorean triplet for which a + b + c = 1000.
Find the product abc.
</p></blockquote>
The first solution to this problem that I came up with was just atrocious :) It was long, bloated and extremely messy. But it worked. If you really want to see it then ask me nicely and I'll post it.</p>

<p>For now I'm going to show you my second attempt, which is a little nicer on the eyes.
{% codeblock lang:haskell %}
main :: IO ()
main = print $ head [ a * b * c</p>

<pre><code>                | b &lt;- [1..400],
                  a &lt;- [b..400],
                  let c = 1000 - a - b,
                  c^2 == a^2 + b^2 ]
</code></pre>

<p>{% endcodeblock %}</p>

<p>It's a mini brute-forcer which uses two variables to count up to 400. I chose 400 as the end number because it seemed like a stupid idea to go as far as 500 when brute forcing since the first of the numbers that fit the criteria wouldn't be anywhere near that high. For each combination of numbers I pick what's left over and check to see if it fits the rules of a Pythagorean triplet. In this case there is only one that does (as per the question).</p>

<p>We can see below that the solution isn't particularly fantastic as far as performance goes. It's not terrible, but approaching .2 seconds for a problem like this is starting to get on the sluggish side.</p>

<pre><code>  Fri Jul 25 21:28 2008 Time and Allocation Profiling Report  (Final)

     main +RTS -p -RTS

  total time  =        0.18 secs   (9 ticks @ 20 ms)
  total alloc =  29,337,532 bytes  (excludes profiling overheads)

COST CENTRE   MODULE  %time %alloc

CAF           Main    100.0  100.0


                                           individual    inherited
COST CENTRE   MODULE      no.    entries  %time %alloc   %time %alloc

MAIN          MAIN          1           0   0.0    0.0   100.0  100.0
 CAF          Main        152          16 100.0  100.0   100.0  100.0
 CAF          GHC.Handle   88           4   0.0    0.0     0.0    0.0
</code></pre>

<p>Another way of brute-force solving this is to abuse a bit of math. We know that each Pythagorean triplet is representative of the sides of a triangle. Given that the sides of a triangle scale evenly when the entire triangle is scaled, we can assume that if we were able to find a triplet whose sum is a factor of 1000, then we could use this factor to generate a, b and c. It turns out that the 5th Pythagorean triplet (8, 15, 17) adds up to 40, and since 40 * 25 == 1000, we can simply multiple each of the values by 25 to get (200, 375, 425).</p>

<p>While this is interesting, brute-force methods aren't never really the nicest way of solving a given problem. In the case of Project Euler it's rare to find a problem that doesn't have some form of trickery that can be abused to get the answer in a much more efficient manner. The theory that should be used is that each Pythagorean triplet can be <a href="http://en.wikipedia.org/wiki/Pythagorean_triple#Generating_a_triple">written in the following form</a>:</p>

<pre><code>k [ m^2 - n^2, 2mn, m^2 + n^2 ]
</code></pre>

<p>This info can be abused to come up with some code to generate the answer rather quickly. At this point, I become tired of the problem and decided not to implement a version that uses this theory. If you decide to write one, please ping me!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler #10]]></title>
    <link href="http://buffered.io/posts/project-euler-10/"/>
    <updated>2008-07-30T21:27:00+10:00</updated>
    <id>http://buffered.io/posts/project-euler-10</id>
    <content type="html"><![CDATA[<p><strong>WARNING!</strong> This post contains a spoiler for Problem #10 listed at <a href="http://projecteuler.net/" title="Project Euler">Project Euler</a>. Do not read the rest of this post if you're planning to attempt to solve the problem yourself.</p>

<!--more-->


<p><a title="Project Euler #10" href="http://projecteuler.net/index.php?section=problems&amp;id=10">Problem #10</a> takes us back into the realm of the relatively boring - prime numbers (again). The question is as follows:<blockquote><p>The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.</p>

<p>Find the sum of all the primes below two million.</p></blockquote>
Exciting stuff! Since we've already got ourselves a relatively nifty prime number generator from a <a title="Project Euler #7" href="http://buffered.io/posts/project-euler-7/">previous post</a>, we can simply reuse this, along with the sum function that comes in <a title="Prelude" href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Prelude</a>, to generate the answer.</p>

<p>Here is what the code looks like:
{% codeblock lang:haskell %}
merge :: (Ord a) => [a] -> [a] -> [a]
merge xs@(x:xt) ys@(y:yt) =
  case compare x y of</p>

<pre><code>LT -&gt; x : (merge xt ys)
EQ -&gt; x : (merge xt yt)
GT -&gt; y : (merge xs yt)
</code></pre>

<p>diff :: (Ord a) => [a] -> [a] -> [a]
diff xs@(x:xt) ys@(y:yt) =
  case compare x y of</p>

<pre><code>LT -&gt; x : (diff xt ys)
EQ -&gt; diff xt yt
GT -&gt; diff xs yt
</code></pre>

<p>primes, nonprimes :: [Integer]
primes    = [2, 3, 5] ++ (diff [7, 9 ..] nonprimes)
nonprimes = foldr1 f $ map g $ tail primes
  where</p>

<pre><code>f (x:xt) ys = x : (merge xt ys)
g p         = [ n * p | n &lt;- [p, p + 2 ..]]
</code></pre>

<p>main :: IO ()
main = print $ sum (takeWhile (&lt;2000000) primes)
{% endcodeblock %}</p>

<p>I don't really have much else to say about this. I won't bother with the performance information because it's not really doing anything too exciting that hasn't already been discussed.</p>

<p>Cheers!</p>
]]></content>
  </entry>
  
</feed>
